/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/mecab-wasm/lib/libmecab.js":
/*!*************************************************!*\
  !*** ./node_modules/mecab-wasm/lib/libmecab.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nvar Module = (function() {\n  var _scriptDir = \"file:///Users/dlossenko/projects/test/node_modules/mecab-wasm/lib/libmecab.js\";\n  \n  return (\nfunction(Module) {\n  Module = Module || {};\n\nvar Module = typeof Module !== \"undefined\" ? Module : {};\n\nvar readyPromiseResolve, readyPromiseReject;\n\nModule[\"ready\"] = new Promise(function(resolve, reject) {\n readyPromiseResolve = resolve;\n readyPromiseReject = reject;\n});\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_mecab_new2\")) {\n Object.defineProperty(Module[\"ready\"], \"_mecab_new2\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _mecab_new2 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_mecab_new2\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _mecab_new2 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_mecab_sparse_tostr3\")) {\n Object.defineProperty(Module[\"ready\"], \"_mecab_sparse_tostr3\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _mecab_sparse_tostr3 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_mecab_sparse_tostr3\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _mecab_sparse_tostr3 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_sbrk\")) {\n Object.defineProperty(Module[\"ready\"], \"_sbrk\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _sbrk on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_sbrk\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _sbrk on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_emscripten_stack_get_end\")) {\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_get_end\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _emscripten_stack_get_end on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_get_end\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _emscripten_stack_get_end on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_emscripten_stack_get_free\")) {\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_get_free\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _emscripten_stack_get_free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_get_free\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _emscripten_stack_get_free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_emscripten_stack_init\")) {\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_init\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _emscripten_stack_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_init\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _emscripten_stack_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_stackSave\")) {\n Object.defineProperty(Module[\"ready\"], \"_stackSave\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _stackSave on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_stackSave\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _stackSave on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_stackRestore\")) {\n Object.defineProperty(Module[\"ready\"], \"_stackRestore\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _stackRestore on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_stackRestore\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _stackRestore on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_stackAlloc\")) {\n Object.defineProperty(Module[\"ready\"], \"_stackAlloc\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _stackAlloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_stackAlloc\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _stackAlloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___wasm_call_ctors\")) {\n Object.defineProperty(Module[\"ready\"], \"___wasm_call_ctors\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting ___wasm_call_ctors on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"___wasm_call_ctors\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting ___wasm_call_ctors on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_fflush\")) {\n Object.defineProperty(Module[\"ready\"], \"_fflush\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_fflush\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___errno_location\")) {\n Object.defineProperty(Module[\"ready\"], \"___errno_location\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting ___errno_location on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"___errno_location\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting ___errno_location on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_emscripten_get_sbrk_ptr\")) {\n Object.defineProperty(Module[\"ready\"], \"_emscripten_get_sbrk_ptr\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _emscripten_get_sbrk_ptr on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_emscripten_get_sbrk_ptr\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _emscripten_get_sbrk_ptr on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_emscripten_stack_get_base\")) {\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_get_base\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _emscripten_stack_get_base on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_emscripten_stack_get_base\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _emscripten_stack_get_base on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_malloc\")) {\n Object.defineProperty(Module[\"ready\"], \"_malloc\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _malloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_malloc\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _malloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_free\")) {\n Object.defineProperty(Module[\"ready\"], \"_free\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_free\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _free on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"onRuntimeInitialized\")) {\n Object.defineProperty(Module[\"ready\"], \"onRuntimeInitialized\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"onRuntimeInitialized\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Module.expectedDataFileDownloads) {\n Module.expectedDataFileDownloads = 0;\n}\n\nModule.expectedDataFileDownloads++;\n\n(function() {\n var loadPackage = function(metadata) {\n  var PACKAGE_PATH = \"\";\n  if (typeof window === \"object\") {\n   PACKAGE_PATH = window[\"encodeURIComponent\"](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf(\"/\")) + \"/\");\n  } else if (typeof process === \"undefined\" && typeof location !== \"undefined\") {\n   PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf(\"/\")) + \"/\");\n  }\n  var PACKAGE_NAME = \"lib/libmecab.data\";\n  var REMOTE_PACKAGE_BASE = \"libmecab.data\";\n  if (typeof Module[\"locateFilePackage\"] === \"function\" && !Module[\"locateFile\"]) {\n   Module[\"locateFile\"] = Module[\"locateFilePackage\"];\n   err(\"warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)\");\n  }\n  var REMOTE_PACKAGE_NAME = Module[\"locateFile\"] ? Module[\"locateFile\"](REMOTE_PACKAGE_BASE, \"\") : REMOTE_PACKAGE_BASE;\n  var REMOTE_PACKAGE_SIZE = metadata[\"remote_package_size\"];\n  var PACKAGE_UUID = metadata[\"package_uuid\"];\n  function fetchRemotePackage(packageName, packageSize, callback, errback) {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", packageName, true);\n   xhr.responseType = \"arraybuffer\";\n   xhr.onprogress = function(event) {\n    var url = packageName;\n    var size = packageSize;\n    if (event.total) size = event.total;\n    if (event.loaded) {\n     if (!xhr.addedTotal) {\n      xhr.addedTotal = true;\n      if (!Module.dataFileDownloads) Module.dataFileDownloads = {};\n      Module.dataFileDownloads[url] = {\n       loaded: event.loaded,\n       total: size\n      };\n     } else {\n      Module.dataFileDownloads[url].loaded = event.loaded;\n     }\n     var total = 0;\n     var loaded = 0;\n     var num = 0;\n     for (var download in Module.dataFileDownloads) {\n      var data = Module.dataFileDownloads[download];\n      total += data.total;\n      loaded += data.loaded;\n      num++;\n     }\n     total = Math.ceil(total * Module.expectedDataFileDownloads / num);\n     if (Module[\"setStatus\"]) Module[\"setStatus\"](\"Downloading data... (\" + loaded + \"/\" + total + \")\");\n    } else if (!Module.dataFileDownloads) {\n     if (Module[\"setStatus\"]) Module[\"setStatus\"](\"Downloading data...\");\n    }\n   };\n   xhr.onerror = function(event) {\n    throw new Error(\"NetworkError for: \" + packageName);\n   };\n   xhr.onload = function(event) {\n    if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || xhr.status == 0 && xhr.response) {\n     var packageData = xhr.response;\n     callback(packageData);\n    } else {\n     throw new Error(xhr.statusText + \" : \" + xhr.responseURL);\n    }\n   };\n   xhr.send(null);\n  }\n  function handleError(error) {\n   console.error(\"package error:\", error);\n  }\n  var fetchedCallback = null;\n  var fetched = Module[\"getPreloadedPackage\"] ? Module[\"getPreloadedPackage\"](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;\n  if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function(data) {\n   if (fetchedCallback) {\n    fetchedCallback(data);\n    fetchedCallback = null;\n   } else {\n    fetched = data;\n   }\n  }, handleError);\n  function runWithFS() {\n   function assert(check, msg) {\n    if (!check) throw msg + new Error().stack;\n   }\n   Module[\"FS_createPath\"](\"/\", \"usr\", true, true);\n   Module[\"FS_createPath\"](\"/usr\", \"local\", true, true);\n   Module[\"FS_createPath\"](\"/usr/local\", \"etc\", true, true);\n   Module[\"FS_createPath\"](\"/usr/local\", \"lib\", true, true);\n   Module[\"FS_createPath\"](\"/usr/local/lib\", \"mecab\", true, true);\n   Module[\"FS_createPath\"](\"/usr/local/lib/mecab\", \"dic\", true, true);\n   Module[\"FS_createPath\"](\"/usr/local/lib/mecab/dic\", \"ipadic\", true, true);\n   function DataRequest(start, end, audio) {\n    this.start = start;\n    this.end = end;\n    this.audio = audio;\n   }\n   DataRequest.prototype = {\n    requests: {},\n    open: function(mode, name) {\n     this.name = name;\n     this.requests[name] = this;\n     Module[\"addRunDependency\"](\"fp \" + this.name);\n    },\n    send: function() {},\n    onload: function() {\n     var byteArray = this.byteArray.subarray(this.start, this.end);\n     this.finish(byteArray);\n    },\n    finish: function(byteArray) {\n     var that = this;\n     Module[\"FS_createDataFile\"](this.name, null, byteArray, true, true, true);\n     Module[\"removeRunDependency\"](\"fp \" + that.name);\n     this.requests[this.name] = null;\n    }\n   };\n   var files = metadata[\"files\"];\n   for (var i = 0; i < files.length; ++i) {\n    new DataRequest(files[i][\"start\"], files[i][\"end\"], files[i][\"audio\"] || 0).open(\"GET\", files[i][\"filename\"]);\n   }\n   function processPackageData(arrayBuffer) {\n    assert(arrayBuffer, \"Loading data file failed.\");\n    assert(arrayBuffer instanceof ArrayBuffer, \"bad input to processPackageData\");\n    var byteArray = new Uint8Array(arrayBuffer);\n    var curr;\n    DataRequest.prototype.byteArray = byteArray;\n    var files = metadata[\"files\"];\n    for (var i = 0; i < files.length; ++i) {\n     DataRequest.prototype.requests[files[i].filename].onload();\n    }\n    Module[\"removeRunDependency\"](\"datafile_lib/libmecab.data\");\n   }\n   Module[\"addRunDependency\"](\"datafile_lib/libmecab.data\");\n   if (!Module.preloadResults) Module.preloadResults = {};\n   Module.preloadResults[PACKAGE_NAME] = {\n    fromCache: false\n   };\n   if (fetched) {\n    processPackageData(fetched);\n    fetched = null;\n   } else {\n    fetchedCallback = processPackageData;\n   }\n  }\n  if (Module[\"calledRun\"]) {\n   runWithFS();\n  } else {\n   if (!Module[\"preRun\"]) Module[\"preRun\"] = [];\n   Module[\"preRun\"].push(runWithFS);\n  }\n };\n loadPackage({\n  \"files\": [ {\n   \"filename\": \"/usr/local/etc/mecabrc\",\n   \"start\": 0,\n   \"end\": 295\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/matrix.bin\",\n   \"start\": 295,\n   \"end\": 3464011\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/sys.dic\",\n   \"start\": 3464011,\n   \"end\": 52663038\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/unk.dic\",\n   \"start\": 52663038,\n   \"end\": 52668728\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/char.bin\",\n   \"start\": 52668728,\n   \"end\": 52931224\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/rewrite.def\",\n   \"start\": 52931224,\n   \"end\": 52937465\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/dicrc\",\n   \"start\": 52937465,\n   \"end\": 52938158\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/left-id.def\",\n   \"start\": 52938158,\n   \"end\": 52994068\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/right-id.def\",\n   \"start\": 52994068,\n   \"end\": 53049978\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/.keep\",\n   \"start\": 53049978,\n   \"end\": 53049978\n  }, {\n   \"filename\": \"/usr/local/lib/mecab/dic/ipadic/pos-id.def\",\n   \"start\": 53049978,\n   \"end\": 53051455\n  } ],\n  \"remote_package_size\": 53051455,\n  \"package_uuid\": \"ee5a9b0b-426a-4a3b-8396-a665123cba94\"\n });\n})();\n\nvar necessaryPreJSTasks = Module[\"preRun\"].slice();\n\nif (!Module[\"preRun\"]) throw \"Module.preRun should exist because file support used it; did a pre-js delete it?\";\n\nnecessaryPreJSTasks.forEach(function(task) {\n if (Module[\"preRun\"].indexOf(task) < 0) throw \"All preRun tasks that exist before user pre-js code should remain after; did you replace Module or modify Module.preRun?\";\n});\n\nvar moduleOverrides = {};\n\nvar key;\n\nfor (key in Module) {\n if (Module.hasOwnProperty(key)) {\n  moduleOverrides[key] = Module[key];\n }\n}\n\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = function(status, toThrow) {\n throw toThrow;\n};\n\nvar ENVIRONMENT_IS_WEB = typeof window === \"object\";\n\nvar ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n\nvar ENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\n\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module[\"ENVIRONMENT\"]) {\n throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\");\n}\n\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n if (Module[\"locateFile\"]) {\n  return Module[\"locateFile\"](path, scriptDirectory);\n }\n return scriptDirectory + path;\n}\n\nvar read_, readAsync, readBinary, setWindowTitle;\n\nfunction logExceptionOnExit(e) {\n if (e instanceof ExitStatus) return;\n var toLog = e;\n if (e && typeof e === \"object\" && e.stack) {\n  toLog = [ e, e.stack ];\n }\n err(\"exiting due to exception: \" + toLog);\n}\n\nif (ENVIRONMENT_IS_SHELL) {\n if (typeof process === \"object\" && \"function\" === \"function\" || typeof window === \"object\" || typeof importScripts === \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n if (typeof read != \"undefined\") {\n  read_ = function shell_read(f) {\n   return read(f);\n  };\n }\n readBinary = function readBinary(f) {\n  var data;\n  if (typeof readbuffer === \"function\") {\n   return new Uint8Array(readbuffer(f));\n  }\n  data = read(f, \"binary\");\n  assert(typeof data === \"object\");\n  return data;\n };\n readAsync = function readAsync(f, onload, onerror) {\n  setTimeout(function() {\n   onload(readBinary(f));\n  }, 0);\n };\n if (typeof scriptArgs != \"undefined\") {\n  arguments_ = scriptArgs;\n } else if (typeof arguments != \"undefined\") {\n  arguments_ = arguments;\n }\n if (typeof quit === \"function\") {\n  quit_ = function(status, toThrow) {\n   logExceptionOnExit(toThrow);\n   quit(status);\n  };\n }\n if (typeof print !== \"undefined\") {\n  if (typeof console === \"undefined\") console = {};\n  console.log = print;\n  console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = self.location.href;\n } else if (typeof document !== \"undefined\" && document.currentScript) {\n  scriptDirectory = document.currentScript.src;\n }\n if (_scriptDir) {\n  scriptDirectory = _scriptDir;\n }\n if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n } else {\n  scriptDirectory = \"\";\n }\n if (!(typeof window === \"object\" || typeof importScripts === \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n {\n  read_ = function(url) {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, false);\n   xhr.send(null);\n   return xhr.responseText;\n  };\n  if (ENVIRONMENT_IS_WORKER) {\n   readBinary = function(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    xhr.responseType = \"arraybuffer\";\n    xhr.send(null);\n    return new Uint8Array(xhr.response);\n   };\n  }\n  readAsync = function(url, onload, onerror) {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, true);\n   xhr.responseType = \"arraybuffer\";\n   xhr.onload = function() {\n    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n     onload(xhr.response);\n     return;\n    }\n    onerror();\n   };\n   xhr.onerror = onerror;\n   xhr.send(null);\n  };\n }\n setWindowTitle = function(title) {\n  document.title = title;\n };\n} else {\n throw new Error(\"environment detection error\");\n}\n\nvar out = Module[\"print\"] || console.log.bind(console);\n\nvar err = Module[\"printErr\"] || console.warn.bind(console);\n\nfor (key in moduleOverrides) {\n if (moduleOverrides.hasOwnProperty(key)) {\n  Module[key] = moduleOverrides[key];\n }\n}\n\nmoduleOverrides = null;\n\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"arguments\")) {\n Object.defineProperty(Module, \"arguments\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.arguments has been replaced with plain arguments_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"thisProgram\")) {\n Object.defineProperty(Module, \"thisProgram\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.thisProgram has been replaced with plain thisProgram (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"quit\")) {\n Object.defineProperty(Module, \"quit\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.quit has been replaced with plain quit_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nassert(typeof Module[\"memoryInitializerPrefixURL\"] === \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"pthreadMainPrefixURL\"] === \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"cdInitializerPrefixURL\"] === \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"filePackagePrefixURL\"] === \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"read\"] === \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\n\nassert(typeof Module[\"readAsync\"] === \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\n\nassert(typeof Module[\"readBinary\"] === \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\n\nassert(typeof Module[\"setWindowTitle\"] === \"undefined\", \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\");\n\nassert(typeof Module[\"TOTAL_MEMORY\"] === \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\n\nif (!Object.getOwnPropertyDescriptor(Module, \"read\")) {\n Object.defineProperty(Module, \"read\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.read has been replaced with plain read_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsync\")) {\n Object.defineProperty(Module, \"readAsync\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.readAsync has been replaced with plain readAsync (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readBinary\")) {\n Object.defineProperty(Module, \"readBinary\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.readBinary has been replaced with plain readBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setWindowTitle\")) {\n Object.defineProperty(Module, \"setWindowTitle\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.setWindowTitle has been replaced with plain setWindowTitle (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nvar IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\n\nvar PROXYFS = \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\n\nvar WORKERFS = \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\n\nvar NODEFS = \"NODEFS is no longer included by default; build with -lnodefs.js\";\n\nassert(!ENVIRONMENT_IS_NODE, \"node environment detected but not enabled at build time.  Add 'node' to `-s ENVIRONMENT` to enable.\");\n\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-s ENVIRONMENT` to enable.\");\n\nvar STACK_ALIGN = 16;\n\nfunction getNativeTypeSize(type) {\n switch (type) {\n case \"i1\":\n case \"i8\":\n  return 1;\n\n case \"i16\":\n  return 2;\n\n case \"i32\":\n  return 4;\n\n case \"i64\":\n  return 8;\n\n case \"float\":\n  return 4;\n\n case \"double\":\n  return 8;\n\n default:\n  {\n   if (type[type.length - 1] === \"*\") {\n    return 4;\n   } else if (type[0] === \"i\") {\n    var bits = Number(type.substr(1));\n    assert(bits % 8 === 0, \"getNativeTypeSize invalid bits \" + bits + \", type \" + type);\n    return bits / 8;\n   } else {\n    return 0;\n   }\n  }\n }\n}\n\nfunction warnOnce(text) {\n if (!warnOnce.shown) warnOnce.shown = {};\n if (!warnOnce.shown[text]) {\n  warnOnce.shown[text] = 1;\n  err(text);\n }\n}\n\nfunction convertJsFunctionToWasm(func, sig) {\n if (typeof WebAssembly.Function === \"function\") {\n  var typeNames = {\n   \"i\": \"i32\",\n   \"j\": \"i64\",\n   \"f\": \"f32\",\n   \"d\": \"f64\"\n  };\n  var type = {\n   parameters: [],\n   results: sig[0] == \"v\" ? [] : [ typeNames[sig[0]] ]\n  };\n  for (var i = 1; i < sig.length; ++i) {\n   type.parameters.push(typeNames[sig[i]]);\n  }\n  return new WebAssembly.Function(type, func);\n }\n var typeSection = [ 1, 0, 1, 96 ];\n var sigRet = sig.slice(0, 1);\n var sigParam = sig.slice(1);\n var typeCodes = {\n  \"i\": 127,\n  \"j\": 126,\n  \"f\": 125,\n  \"d\": 124\n };\n typeSection.push(sigParam.length);\n for (var i = 0; i < sigParam.length; ++i) {\n  typeSection.push(typeCodes[sigParam[i]]);\n }\n if (sigRet == \"v\") {\n  typeSection.push(0);\n } else {\n  typeSection = typeSection.concat([ 1, typeCodes[sigRet] ]);\n }\n typeSection[1] = typeSection.length - 2;\n var bytes = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0 ].concat(typeSection, [ 2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0 ]));\n var module = new WebAssembly.Module(bytes);\n var instance = new WebAssembly.Instance(module, {\n  \"e\": {\n   \"f\": func\n  }\n });\n var wrappedFunc = instance.exports[\"f\"];\n return wrappedFunc;\n}\n\nvar freeTableIndexes = [];\n\nvar functionsInTableMap;\n\nfunction getEmptyTableSlot() {\n if (freeTableIndexes.length) {\n  return freeTableIndexes.pop();\n }\n try {\n  wasmTable.grow(1);\n } catch (err) {\n  if (!(err instanceof RangeError)) {\n   throw err;\n  }\n  throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n }\n return wasmTable.length - 1;\n}\n\nfunction addFunctionWasm(func, sig) {\n if (!functionsInTableMap) {\n  functionsInTableMap = new WeakMap();\n  for (var i = 0; i < wasmTable.length; i++) {\n   var item = wasmTable.get(i);\n   if (item) {\n    functionsInTableMap.set(item, i);\n   }\n  }\n }\n if (functionsInTableMap.has(func)) {\n  return functionsInTableMap.get(func);\n }\n var ret = getEmptyTableSlot();\n try {\n  wasmTable.set(ret, func);\n } catch (err) {\n  if (!(err instanceof TypeError)) {\n   throw err;\n  }\n  assert(typeof sig !== \"undefined\", \"Missing signature argument to addFunction: \" + func);\n  var wrapped = convertJsFunctionToWasm(func, sig);\n  wasmTable.set(ret, wrapped);\n }\n functionsInTableMap.set(func, ret);\n return ret;\n}\n\nfunction removeFunction(index) {\n functionsInTableMap.delete(wasmTable.get(index));\n freeTableIndexes.push(index);\n}\n\nfunction addFunction(func, sig) {\n assert(typeof func !== \"undefined\");\n return addFunctionWasm(func, sig);\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n tempRet0 = value;\n};\n\nvar getTempRet0 = function() {\n return tempRet0;\n};\n\nvar wasmBinary;\n\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"wasmBinary\")) {\n Object.defineProperty(Module, \"wasmBinary\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.wasmBinary has been replaced with plain wasmBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nvar noExitRuntime = Module[\"noExitRuntime\"] || true;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"noExitRuntime\")) {\n Object.defineProperty(Module, \"noExitRuntime\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.noExitRuntime has been replaced with plain noExitRuntime (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (typeof WebAssembly !== \"object\") {\n abort(\"no native wasm support detected\");\n}\n\nfunction setValue(ptr, value, type, noSafe) {\n type = type || \"i8\";\n if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n if (noSafe) {\n  switch (type) {\n  case \"i1\":\n   HEAP8[ptr >> 0] = value;\n   break;\n\n  case \"i8\":\n   HEAP8[ptr >> 0] = value;\n   break;\n\n  case \"i16\":\n   HEAP16[ptr >> 1] = value;\n   break;\n\n  case \"i32\":\n   HEAP32[ptr >> 2] = value;\n   break;\n\n  case \"i64\":\n   tempI64 = [ value >>> 0, (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n   HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n   break;\n\n  case \"float\":\n   HEAPF32[ptr >> 2] = value;\n   break;\n\n  case \"double\":\n   HEAPF64[ptr >> 3] = value;\n   break;\n\n  default:\n   abort(\"invalid type for setValue: \" + type);\n  }\n } else {\n  switch (type) {\n  case \"i1\":\n   SAFE_HEAP_STORE(ptr | 0, value | 0, 1);\n   break;\n\n  case \"i8\":\n   SAFE_HEAP_STORE(ptr | 0, value | 0, 1);\n   break;\n\n  case \"i16\":\n   SAFE_HEAP_STORE(ptr | 0, value | 0, 2);\n   break;\n\n  case \"i32\":\n   SAFE_HEAP_STORE(ptr | 0, value | 0, 4);\n   break;\n\n  case \"i64\":\n   tempI64 = [ value >>> 0, (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n   SAFE_HEAP_STORE(ptr | 0, tempI64[0] | 0, 4), SAFE_HEAP_STORE(ptr + 4 | 0, tempI64[1] | 0, 4);\n   break;\n\n  case \"float\":\n   SAFE_HEAP_STORE_D(ptr | 0, Math.fround(value), 4);\n   break;\n\n  case \"double\":\n   SAFE_HEAP_STORE_D(ptr | 0, +value, 8);\n   break;\n\n  default:\n   abort(\"invalid type for setValue: \" + type);\n  }\n }\n}\n\nfunction getValue(ptr, type, noSafe) {\n type = type || \"i8\";\n if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n if (noSafe) {\n  switch (type) {\n  case \"i1\":\n   return HEAP8[ptr >> 0];\n\n  case \"i8\":\n   return HEAP8[ptr >> 0];\n\n  case \"i16\":\n   return HEAP16[ptr >> 1];\n\n  case \"i32\":\n   return HEAP32[ptr >> 2];\n\n  case \"i64\":\n   return HEAP32[ptr >> 2];\n\n  case \"float\":\n   return HEAPF32[ptr >> 2];\n\n  case \"double\":\n   return HEAPF64[ptr >> 3];\n\n  default:\n   abort(\"invalid type for getValue: \" + type);\n  }\n } else {\n  switch (type) {\n  case \"i1\":\n   return SAFE_HEAP_LOAD(ptr | 0, 1, 0) | 0;\n\n  case \"i8\":\n   return SAFE_HEAP_LOAD(ptr | 0, 1, 0) | 0;\n\n  case \"i16\":\n   return SAFE_HEAP_LOAD(ptr | 0, 2, 0) | 0;\n\n  case \"i32\":\n   return SAFE_HEAP_LOAD(ptr | 0, 4, 0) | 0;\n\n  case \"i64\":\n   return SAFE_HEAP_LOAD(ptr | 0, 8, 0) | 0;\n\n  case \"float\":\n   return Math.fround(SAFE_HEAP_LOAD_D(ptr | 0, 4, 0));\n\n  case \"double\":\n   return +SAFE_HEAP_LOAD_D(ptr | 0, 8, 0);\n\n  default:\n   abort(\"invalid type for getValue: \" + type);\n  }\n }\n return null;\n}\n\nfunction getSafeHeapType(bytes, isFloat) {\n switch (bytes) {\n case 1:\n  return \"i8\";\n\n case 2:\n  return \"i16\";\n\n case 4:\n  return isFloat ? \"float\" : \"i32\";\n\n case 8:\n  return \"double\";\n\n default:\n  assert(0);\n }\n}\n\nfunction SAFE_HEAP_STORE(dest, value, bytes, isFloat) {\n if (dest <= 0) abort(\"segmentation fault storing \" + bytes + \" bytes to address \" + dest);\n if (dest % bytes !== 0) abort(\"alignment error storing to address \" + dest + \", which was expected to be aligned to a multiple of \" + bytes);\n if (runtimeInitialized) {\n  var brk = _sbrk() >>> 0;\n  if (dest + bytes > brk) abort(\"segmentation fault, exceeded the top of the available dynamic heap when storing \" + bytes + \" bytes to address \" + dest + \". DYNAMICTOP=\" + brk);\n  assert(brk >= _emscripten_stack_get_base());\n  assert(brk <= HEAP8.length);\n }\n setValue(dest, value, getSafeHeapType(bytes, isFloat), 1);\n return value;\n}\n\nfunction SAFE_HEAP_STORE_D(dest, value, bytes) {\n return SAFE_HEAP_STORE(dest, value, bytes, true);\n}\n\nfunction SAFE_HEAP_LOAD(dest, bytes, unsigned, isFloat) {\n if (dest <= 0) abort(\"segmentation fault loading \" + bytes + \" bytes from address \" + dest);\n if (dest % bytes !== 0) abort(\"alignment error loading from address \" + dest + \", which was expected to be aligned to a multiple of \" + bytes);\n if (runtimeInitialized) {\n  var brk = _sbrk() >>> 0;\n  if (dest + bytes > brk) abort(\"segmentation fault, exceeded the top of the available dynamic heap when loading \" + bytes + \" bytes from address \" + dest + \". DYNAMICTOP=\" + brk);\n  assert(brk >= _emscripten_stack_get_base());\n  assert(brk <= HEAP8.length);\n }\n var type = getSafeHeapType(bytes, isFloat);\n var ret = getValue(dest, type, 1);\n if (unsigned) ret = unSign(ret, parseInt(type.substr(1), 10));\n return ret;\n}\n\nfunction SAFE_HEAP_LOAD_D(dest, bytes, unsigned) {\n return SAFE_HEAP_LOAD(dest, bytes, unsigned, true);\n}\n\nfunction SAFE_FT_MASK(value, mask) {\n var ret = value & mask;\n if (ret !== value) {\n  abort(\"Function table mask error: function pointer is \" + value + \" which is masked by \" + mask + \", the likely cause of this is that the function pointer is being called by the wrong type.\");\n }\n return ret;\n}\n\nfunction segfault() {\n abort(\"segmentation fault\");\n}\n\nfunction alignfault() {\n abort(\"alignment fault\");\n}\n\nfunction ftfault() {\n abort(\"Function table mask error\");\n}\n\nvar wasmMemory;\n\nvar ABORT = false;\n\nvar EXITSTATUS;\n\nfunction assert(condition, text) {\n if (!condition) {\n  abort(\"Assertion failed: \" + text);\n }\n}\n\nfunction getCFunc(ident) {\n var func = Module[\"_\" + ident];\n assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n return func;\n}\n\nfunction ccall(ident, returnType, argTypes, args, opts) {\n var toC = {\n  \"string\": function(str) {\n   var ret = 0;\n   if (str !== null && str !== undefined && str !== 0) {\n    var len = (str.length << 2) + 1;\n    ret = stackAlloc(len);\n    stringToUTF8(str, ret, len);\n   }\n   return ret;\n  },\n  \"array\": function(arr) {\n   var ret = stackAlloc(arr.length);\n   writeArrayToMemory(arr, ret);\n   return ret;\n  }\n };\n function convertReturnValue(ret) {\n  if (returnType === \"string\") return UTF8ToString(ret);\n  if (returnType === \"boolean\") return Boolean(ret);\n  return ret;\n }\n var func = getCFunc(ident);\n var cArgs = [];\n var stack = 0;\n assert(returnType !== \"array\", 'Return type should not be \"array\".');\n if (args) {\n  for (var i = 0; i < args.length; i++) {\n   var converter = toC[argTypes[i]];\n   if (converter) {\n    if (stack === 0) stack = stackSave();\n    cArgs[i] = converter(args[i]);\n   } else {\n    cArgs[i] = args[i];\n   }\n  }\n }\n var ret = func.apply(null, cArgs);\n function onDone(ret) {\n  if (stack !== 0) stackRestore(stack);\n  return convertReturnValue(ret);\n }\n ret = onDone(ret);\n return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n return function() {\n  return ccall(ident, returnType, argTypes, arguments, opts);\n };\n}\n\nvar ALLOC_NORMAL = 0;\n\nvar ALLOC_STACK = 1;\n\nfunction allocate(slab, allocator) {\n var ret;\n assert(typeof allocator === \"number\", \"allocate no longer takes a type argument\");\n assert(typeof slab !== \"number\", \"allocate no longer takes a number as arg0\");\n if (allocator == ALLOC_STACK) {\n  ret = stackAlloc(slab.length);\n } else {\n  ret = _malloc(slab.length);\n }\n if (slab.subarray || slab.slice) {\n  HEAPU8.set(slab, ret);\n } else {\n  HEAPU8.set(new Uint8Array(slab), ret);\n }\n return ret;\n}\n\nvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n var endIdx = idx + maxBytesToRead;\n var endPtr = idx;\n while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n  return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n } else {\n  var str = \"\";\n  while (idx < endPtr) {\n   var u0 = heap[idx++];\n   if (!(u0 & 128)) {\n    str += String.fromCharCode(u0);\n    continue;\n   }\n   var u1 = heap[idx++] & 63;\n   if ((u0 & 224) == 192) {\n    str += String.fromCharCode((u0 & 31) << 6 | u1);\n    continue;\n   }\n   var u2 = heap[idx++] & 63;\n   if ((u0 & 240) == 224) {\n    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n   } else {\n    if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte 0x\" + u0.toString(16) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\n    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n   }\n   if (u0 < 65536) {\n    str += String.fromCharCode(u0);\n   } else {\n    var ch = u0 - 65536;\n    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n   }\n  }\n }\n return str;\n}\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n}\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n if (!(maxBytesToWrite > 0)) return 0;\n var startIdx = outIdx;\n var endIdx = outIdx + maxBytesToWrite - 1;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) {\n   var u1 = str.charCodeAt(++i);\n   u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n  }\n  if (u <= 127) {\n   if (outIdx >= endIdx) break;\n   heap[outIdx++] = u;\n  } else if (u <= 2047) {\n   if (outIdx + 1 >= endIdx) break;\n   heap[outIdx++] = 192 | u >> 6;\n   heap[outIdx++] = 128 | u & 63;\n  } else if (u <= 65535) {\n   if (outIdx + 2 >= endIdx) break;\n   heap[outIdx++] = 224 | u >> 12;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  } else {\n   if (outIdx + 3 >= endIdx) break;\n   if (u > 1114111) warnOnce(\"Invalid Unicode code point 0x\" + u.toString(16) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\n   heap[outIdx++] = 240 | u >> 18;\n   heap[outIdx++] = 128 | u >> 12 & 63;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  }\n }\n heap[outIdx] = 0;\n return outIdx - startIdx;\n}\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n}\n\nfunction lengthBytesUTF8(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;\n }\n return len;\n}\n\nfunction AsciiToString(ptr) {\n var str = \"\";\n while (1) {\n  var ch = SAFE_HEAP_LOAD(ptr++ | 0, 1, 1) >>> 0;\n  if (!ch) return str;\n  str += String.fromCharCode(ch);\n }\n}\n\nfunction stringToAscii(str, outPtr) {\n return writeAsciiToMemory(str, outPtr, false);\n}\n\nvar UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\nfunction UTF16ToString(ptr, maxBytesToRead) {\n assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\n var endPtr = ptr;\n var idx = endPtr >> 1;\n var maxIdx = idx + maxBytesToRead / 2;\n while (!(idx >= maxIdx) && SAFE_HEAP_LOAD(idx * 2, 2, 1)) ++idx;\n endPtr = idx << 1;\n if (endPtr - ptr > 32 && UTF16Decoder) {\n  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n } else {\n  var str = \"\";\n  for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n   var codeUnit = SAFE_HEAP_LOAD(ptr + i * 2 | 0, 2, 0) | 0;\n   if (codeUnit == 0) break;\n   str += String.fromCharCode(codeUnit);\n  }\n  return str;\n }\n}\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 2) return 0;\n maxBytesToWrite -= 2;\n var startPtr = outPtr;\n var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n for (var i = 0; i < numCharsToWrite; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  SAFE_HEAP_STORE(outPtr | 0, codeUnit | 0, 2);\n  outPtr += 2;\n }\n SAFE_HEAP_STORE(outPtr | 0, 0 | 0, 2);\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF16(str) {\n return str.length * 2;\n}\n\nfunction UTF32ToString(ptr, maxBytesToRead) {\n assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\n var i = 0;\n var str = \"\";\n while (!(i >= maxBytesToRead / 4)) {\n  var utf32 = SAFE_HEAP_LOAD(ptr + i * 4 | 0, 4, 0) | 0;\n  if (utf32 == 0) break;\n  ++i;\n  if (utf32 >= 65536) {\n   var ch = utf32 - 65536;\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n  } else {\n   str += String.fromCharCode(utf32);\n  }\n }\n return str;\n}\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 4) return 0;\n var startPtr = outPtr;\n var endPtr = startPtr + maxBytesToWrite - 4;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) {\n   var trailSurrogate = str.charCodeAt(++i);\n   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n  }\n  SAFE_HEAP_STORE(outPtr | 0, codeUnit | 0, 4);\n  outPtr += 4;\n  if (outPtr + 4 > endPtr) break;\n }\n SAFE_HEAP_STORE(outPtr | 0, 0 | 0, 4);\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF32(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n  len += 4;\n }\n return len;\n}\n\nfunction allocateUTF8(str) {\n var size = lengthBytesUTF8(str) + 1;\n var ret = _malloc(size);\n if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n return ret;\n}\n\nfunction allocateUTF8OnStack(str) {\n var size = lengthBytesUTF8(str) + 1;\n var ret = stackAlloc(size);\n stringToUTF8Array(str, HEAP8, ret, size);\n return ret;\n}\n\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n warnOnce(\"writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!\");\n var lastChar, end;\n if (dontAddNull) {\n  end = buffer + lengthBytesUTF8(string);\n  lastChar = SAFE_HEAP_LOAD(end, 1, 0);\n }\n stringToUTF8(string, buffer, Infinity);\n if (dontAddNull) SAFE_HEAP_STORE(end, lastChar, 1);\n}\n\nfunction writeArrayToMemory(array, buffer) {\n assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n for (var i = 0; i < str.length; ++i) {\n  assert(str.charCodeAt(i) === str.charCodeAt(i) & 255);\n  SAFE_HEAP_STORE(buffer++ | 0, str.charCodeAt(i) | 0, 1);\n }\n if (!dontAddNull) SAFE_HEAP_STORE(buffer | 0, 0 | 0, 1);\n}\n\nfunction alignUp(x, multiple) {\n if (x % multiple > 0) {\n  x += multiple - x % multiple;\n }\n return x;\n}\n\nvar HEAP, buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n buffer = buf;\n Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n}\n\nvar TOTAL_STACK = 5242880;\n\nif (Module[\"TOTAL_STACK\"]) assert(TOTAL_STACK === Module[\"TOTAL_STACK\"], \"the stack size can no longer be determined at runtime\");\n\nvar INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 199950336;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"INITIAL_MEMORY\")) {\n Object.defineProperty(Module, \"INITIAL_MEMORY\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.INITIAL_MEMORY has been replaced with plain INITIAL_MEMORY (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nassert(INITIAL_MEMORY >= TOTAL_STACK, \"INITIAL_MEMORY should be larger than TOTAL_STACK, was \" + INITIAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n\nassert(typeof Int32Array !== \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, \"JS engine does not provide full typed array support\");\n\nassert(!Module[\"wasmMemory\"], \"Use of `wasmMemory` detected.  Use -s IMPORTED_MEMORY to define wasmMemory externally\");\n\nassert(INITIAL_MEMORY == 199950336, \"Detected runtime INITIAL_MEMORY setting.  Use -s IMPORTED_MEMORY to define wasmMemory dynamically\");\n\nvar wasmTable;\n\nfunction writeStackCookie() {\n var max = _emscripten_stack_get_end();\n assert((max & 3) == 0);\n SAFE_HEAP_STORE(((max >> 2) + 1) * 4, 34821223, 4);\n SAFE_HEAP_STORE(((max >> 2) + 2) * 4, 2310721022, 4);\n}\n\nfunction checkStackCookie() {\n if (ABORT) return;\n var max = _emscripten_stack_get_end();\n var cookie1 = SAFE_HEAP_LOAD(((max >> 2) + 1) * 4, 4, 1);\n var cookie2 = SAFE_HEAP_LOAD(((max >> 2) + 2) * 4, 4, 1);\n if (cookie1 != 34821223 || cookie2 != 2310721022) {\n  abort(\"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x\" + cookie2.toString(16) + \" \" + cookie1.toString(16));\n }\n}\n\n(function() {\n var h16 = new Int16Array(1);\n var h8 = new Int8Array(h16.buffer);\n h16[0] = 25459;\n if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)\";\n})();\n\nvar __ATPRERUN__ = [];\n\nvar __ATINIT__ = [];\n\nvar __ATEXIT__ = [];\n\nvar __ATPOSTRUN__ = [];\n\nvar runtimeInitialized = false;\n\nvar runtimeExited = false;\n\nvar runtimeKeepaliveCounter = 0;\n\nfunction keepRuntimeAlive() {\n return noExitRuntime || runtimeKeepaliveCounter > 0;\n}\n\nfunction preRun() {\n if (Module[\"preRun\"]) {\n  if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n  while (Module[\"preRun\"].length) {\n   addOnPreRun(Module[\"preRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n checkStackCookie();\n assert(!runtimeInitialized);\n runtimeInitialized = true;\n if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n FS.ignorePermissions = false;\n TTY.init();\n callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction exitRuntime() {\n checkStackCookie();\n runtimeExited = true;\n}\n\nfunction postRun() {\n checkStackCookie();\n if (Module[\"postRun\"]) {\n  if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n  while (Module[\"postRun\"].length) {\n   addOnPostRun(Module[\"postRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n __ATINIT__.unshift(cb);\n}\n\nfunction addOnExit(cb) {}\n\nfunction addOnPostRun(cb) {\n __ATPOSTRUN__.unshift(cb);\n}\n\nassert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nvar runDependencies = 0;\n\nvar runDependencyWatcher = null;\n\nvar dependenciesFulfilled = null;\n\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n var orig = id;\n while (1) {\n  if (!runDependencyTracking[id]) return id;\n  id = orig + Math.random();\n }\n}\n\nfunction addRunDependency(id) {\n runDependencies++;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (id) {\n  assert(!runDependencyTracking[id]);\n  runDependencyTracking[id] = 1;\n  if (runDependencyWatcher === null && typeof setInterval !== \"undefined\") {\n   runDependencyWatcher = setInterval(function() {\n    if (ABORT) {\n     clearInterval(runDependencyWatcher);\n     runDependencyWatcher = null;\n     return;\n    }\n    var shown = false;\n    for (var dep in runDependencyTracking) {\n     if (!shown) {\n      shown = true;\n      err(\"still waiting on run dependencies:\");\n     }\n     err(\"dependency: \" + dep);\n    }\n    if (shown) {\n     err(\"(end of list)\");\n    }\n   }, 1e4);\n  }\n } else {\n  err(\"warning: run dependency added without ID\");\n }\n}\n\nfunction removeRunDependency(id) {\n runDependencies--;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (id) {\n  assert(runDependencyTracking[id]);\n  delete runDependencyTracking[id];\n } else {\n  err(\"warning: run dependency removed without ID\");\n }\n if (runDependencies == 0) {\n  if (runDependencyWatcher !== null) {\n   clearInterval(runDependencyWatcher);\n   runDependencyWatcher = null;\n  }\n  if (dependenciesFulfilled) {\n   var callback = dependenciesFulfilled;\n   dependenciesFulfilled = null;\n   callback();\n  }\n }\n}\n\nModule[\"preloadedImages\"] = {};\n\nModule[\"preloadedAudios\"] = {};\n\nfunction abort(what) {\n {\n  if (Module[\"onAbort\"]) {\n   Module[\"onAbort\"](what);\n  }\n }\n what = \"Aborted(\" + what + \")\";\n err(what);\n ABORT = true;\n EXITSTATUS = 1;\n var e = new WebAssembly.RuntimeError(what);\n readyPromiseReject(e);\n throw e;\n}\n\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\nfunction isDataURI(filename) {\n return filename.startsWith(dataURIPrefix);\n}\n\nfunction isFileURI(filename) {\n return filename.startsWith(\"file://\");\n}\n\nfunction createExportWrapper(name, fixedasm) {\n return function() {\n  var displayName = name;\n  var asm = fixedasm;\n  if (!fixedasm) {\n   asm = Module[\"asm\"];\n  }\n  assert(runtimeInitialized, \"native function `\" + displayName + \"` called before runtime initialization\");\n  assert(!runtimeExited, \"native function `\" + displayName + \"` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n  if (!asm[name]) {\n   assert(asm[name], \"exported native function `\" + displayName + \"` not found\");\n  }\n  return asm[name].apply(null, arguments);\n };\n}\n\nvar wasmBinaryFile;\n\nif (Module[\"locateFile\"]) {\n wasmBinaryFile = \"libmecab.wasm\";\n if (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n }\n} else {\n wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! libmecab.wasm */ \"./node_modules/mecab-wasm/lib/libmecab.wasm\"), __webpack_require__.b).toString();\n}\n\nfunction getBinary(file) {\n try {\n  if (file == wasmBinaryFile && wasmBinary) {\n   return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n   return readBinary(file);\n  } else {\n   throw \"both async and sync fetching of the wasm failed\";\n  }\n } catch (err) {\n  abort(err);\n }\n}\n\nfunction getBinaryPromise() {\n if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n  if (typeof fetch === \"function\" && !isFileURI(wasmBinaryFile)) {\n   return fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    if (!response[\"ok\"]) {\n     throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n    }\n    return response[\"arrayBuffer\"]();\n   }).catch(function() {\n    return getBinary(wasmBinaryFile);\n   });\n  } else {\n   if (readAsync) {\n    return new Promise(function(resolve, reject) {\n     readAsync(wasmBinaryFile, function(response) {\n      resolve(new Uint8Array(response));\n     }, reject);\n    });\n   }\n  }\n }\n return Promise.resolve().then(function() {\n  return getBinary(wasmBinaryFile);\n });\n}\n\nfunction createWasm() {\n var info = {\n  \"env\": asmLibraryArg,\n  \"wasi_snapshot_preview1\": asmLibraryArg\n };\n function receiveInstance(instance, module) {\n  var exports = instance.exports;\n  Module[\"asm\"] = exports;\n  wasmMemory = Module[\"asm\"][\"memory\"];\n  assert(wasmMemory, \"memory not found in wasm exports\");\n  updateGlobalBufferAndViews(wasmMemory.buffer);\n  wasmTable = Module[\"asm\"][\"__indirect_function_table\"];\n  assert(wasmTable, \"table not found in wasm exports\");\n  addOnInit(Module[\"asm\"][\"__wasm_call_ctors\"]);\n  removeRunDependency(\"wasm-instantiate\");\n }\n addRunDependency(\"wasm-instantiate\");\n var trueModule = Module;\n function receiveInstantiationResult(result) {\n  assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n  trueModule = null;\n  receiveInstance(result[\"instance\"]);\n }\n function instantiateArrayBuffer(receiver) {\n  return getBinaryPromise().then(function(binary) {\n   return WebAssembly.instantiate(binary, info);\n  }).then(function(instance) {\n   return instance;\n  }).then(receiver, function(reason) {\n   err(\"failed to asynchronously prepare wasm: \" + reason);\n   if (isFileURI(wasmBinaryFile)) {\n    err(\"warning: Loading from a file URI (\" + wasmBinaryFile + \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\");\n   }\n   abort(reason);\n  });\n }\n function instantiateAsync() {\n  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \"function\") {\n   return fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    var result = WebAssembly.instantiateStreaming(response, info);\n    return result.then(receiveInstantiationResult, function(reason) {\n     err(\"wasm streaming compile failed: \" + reason);\n     err(\"falling back to ArrayBuffer instantiation\");\n     return instantiateArrayBuffer(receiveInstantiationResult);\n    });\n   });\n  } else {\n   return instantiateArrayBuffer(receiveInstantiationResult);\n  }\n }\n if (Module[\"instantiateWasm\"]) {\n  try {\n   var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n   return exports;\n  } catch (e) {\n   err(\"Module.instantiateWasm callback failed with error: \" + e);\n   return false;\n  }\n }\n instantiateAsync().catch(readyPromiseReject);\n return {};\n}\n\nvar tempDouble;\n\nvar tempI64;\n\nvar ASM_CONSTS = {};\n\nfunction callRuntimeCallbacks(callbacks) {\n while (callbacks.length > 0) {\n  var callback = callbacks.shift();\n  if (typeof callback == \"function\") {\n   callback(Module);\n   continue;\n  }\n  var func = callback.func;\n  if (typeof func === \"number\") {\n   if (callback.arg === undefined) {\n    wasmTable.get(func)();\n   } else {\n    wasmTable.get(func)(callback.arg);\n   }\n  } else {\n   func(callback.arg === undefined ? null : callback.arg);\n  }\n }\n}\n\nfunction demangle(func) {\n warnOnce(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\");\n return func;\n}\n\nfunction demangleAll(text) {\n var regex = /\\b_Z[\\w\\d_]+/g;\n return text.replace(regex, function(x) {\n  var y = demangle(x);\n  return x === y ? x : y + \" [\" + x + \"]\";\n });\n}\n\nfunction handleException(e) {\n if (e instanceof ExitStatus || e == \"unwind\") {\n  return EXITSTATUS;\n }\n quit_(1, e);\n}\n\nfunction jsStackTrace() {\n var error = new Error();\n if (!error.stack) {\n  try {\n   throw new Error();\n  } catch (e) {\n   error = e;\n  }\n  if (!error.stack) {\n   return \"(no stack trace available)\";\n  }\n }\n return error.stack.toString();\n}\n\nfunction stackTrace() {\n var js = jsStackTrace();\n if (Module[\"extraStackTrace\"]) js += \"\\n\" + Module[\"extraStackTrace\"]();\n return demangleAll(js);\n}\n\nfunction unSign(value, bits) {\n if (value >= 0) {\n  return value;\n }\n return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value : Math.pow(2, bits) + value;\n}\n\nfunction ___cxa_allocate_exception(size) {\n return _malloc(size + 16) + 16;\n}\n\nfunction _atexit(func, arg) {}\n\nfunction ___cxa_atexit(a0, a1) {\n return _atexit(a0, a1);\n}\n\nfunction ExceptionInfo(excPtr) {\n this.excPtr = excPtr;\n this.ptr = excPtr - 16;\n this.set_type = function(type) {\n  SAFE_HEAP_STORE(this.ptr + 4 | 0, type | 0, 4);\n };\n this.get_type = function() {\n  return SAFE_HEAP_LOAD(this.ptr + 4 | 0, 4, 0) | 0;\n };\n this.set_destructor = function(destructor) {\n  SAFE_HEAP_STORE(this.ptr + 8 | 0, destructor | 0, 4);\n };\n this.get_destructor = function() {\n  return SAFE_HEAP_LOAD(this.ptr + 8 | 0, 4, 0) | 0;\n };\n this.set_refcount = function(refcount) {\n  SAFE_HEAP_STORE(this.ptr | 0, refcount | 0, 4);\n };\n this.set_caught = function(caught) {\n  caught = caught ? 1 : 0;\n  SAFE_HEAP_STORE(this.ptr + 12 | 0, caught | 0, 1);\n };\n this.get_caught = function() {\n  return (SAFE_HEAP_LOAD(this.ptr + 12 | 0, 1, 0) | 0) != 0;\n };\n this.set_rethrown = function(rethrown) {\n  rethrown = rethrown ? 1 : 0;\n  SAFE_HEAP_STORE(this.ptr + 13 | 0, rethrown | 0, 1);\n };\n this.get_rethrown = function() {\n  return (SAFE_HEAP_LOAD(this.ptr + 13 | 0, 1, 0) | 0) != 0;\n };\n this.init = function(type, destructor) {\n  this.set_type(type);\n  this.set_destructor(destructor);\n  this.set_refcount(0);\n  this.set_caught(false);\n  this.set_rethrown(false);\n };\n this.add_ref = function() {\n  var value = SAFE_HEAP_LOAD(this.ptr | 0, 4, 0) | 0;\n  SAFE_HEAP_STORE(this.ptr | 0, value + 1 | 0, 4);\n };\n this.release_ref = function() {\n  var prev = SAFE_HEAP_LOAD(this.ptr | 0, 4, 0) | 0;\n  SAFE_HEAP_STORE(this.ptr | 0, prev - 1 | 0, 4);\n  assert(prev > 0);\n  return prev === 1;\n };\n}\n\nvar exceptionLast = 0;\n\nvar uncaughtExceptionCount = 0;\n\nfunction ___cxa_throw(ptr, type, destructor) {\n var info = new ExceptionInfo(ptr);\n info.init(type, destructor);\n exceptionLast = ptr;\n uncaughtExceptionCount++;\n throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s NO_DISABLE_EXCEPTION_CATCHING or -s EXCEPTION_CATCHING_ALLOWED=[..] to catch.\";\n}\n\nfunction setErrNo(value) {\n SAFE_HEAP_STORE(___errno_location() | 0, value | 0, 4);\n return value;\n}\n\nvar PATH = {\n splitPath: function(filename) {\n  var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  return splitPathRe.exec(filename).slice(1);\n },\n normalizeArray: function(parts, allowAboveRoot) {\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n   var last = parts[i];\n   if (last === \".\") {\n    parts.splice(i, 1);\n   } else if (last === \"..\") {\n    parts.splice(i, 1);\n    up++;\n   } else if (up) {\n    parts.splice(i, 1);\n    up--;\n   }\n  }\n  if (allowAboveRoot) {\n   for (;up; up--) {\n    parts.unshift(\"..\");\n   }\n  }\n  return parts;\n },\n normalize: function(path) {\n  var isAbsolute = path.charAt(0) === \"/\", trailingSlash = path.substr(-1) === \"/\";\n  path = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\n   return !!p;\n  }), !isAbsolute).join(\"/\");\n  if (!path && !isAbsolute) {\n   path = \".\";\n  }\n  if (path && trailingSlash) {\n   path += \"/\";\n  }\n  return (isAbsolute ? \"/\" : \"\") + path;\n },\n dirname: function(path) {\n  var result = PATH.splitPath(path), root = result[0], dir = result[1];\n  if (!root && !dir) {\n   return \".\";\n  }\n  if (dir) {\n   dir = dir.substr(0, dir.length - 1);\n  }\n  return root + dir;\n },\n basename: function(path) {\n  if (path === \"/\") return \"/\";\n  path = PATH.normalize(path);\n  path = path.replace(/\\/$/, \"\");\n  var lastSlash = path.lastIndexOf(\"/\");\n  if (lastSlash === -1) return path;\n  return path.substr(lastSlash + 1);\n },\n extname: function(path) {\n  return PATH.splitPath(path)[3];\n },\n join: function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return PATH.normalize(paths.join(\"/\"));\n },\n join2: function(l, r) {\n  return PATH.normalize(l + \"/\" + r);\n }\n};\n\nfunction getRandomDevice() {\n if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n  var randomBuffer = new Uint8Array(1);\n  return function() {\n   crypto.getRandomValues(randomBuffer);\n   return randomBuffer[0];\n  };\n } else return function() {\n  abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n };\n}\n\nvar PATH_FS = {\n resolve: function() {\n  var resolvedPath = \"\", resolvedAbsolute = false;\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n   var path = i >= 0 ? arguments[i] : FS.cwd();\n   if (typeof path !== \"string\") {\n    throw new TypeError(\"Arguments to path.resolve must be strings\");\n   } else if (!path) {\n    return \"\";\n   }\n   resolvedPath = path + \"/\" + resolvedPath;\n   resolvedAbsolute = path.charAt(0) === \"/\";\n  }\n  resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function(p) {\n   return !!p;\n  }), !resolvedAbsolute).join(\"/\");\n  return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n },\n relative: function(from, to) {\n  from = PATH_FS.resolve(from).substr(1);\n  to = PATH_FS.resolve(to).substr(1);\n  function trim(arr) {\n   var start = 0;\n   for (;start < arr.length; start++) {\n    if (arr[start] !== \"\") break;\n   }\n   var end = arr.length - 1;\n   for (;end >= 0; end--) {\n    if (arr[end] !== \"\") break;\n   }\n   if (start > end) return [];\n   return arr.slice(start, end - start + 1);\n  }\n  var fromParts = trim(from.split(\"/\"));\n  var toParts = trim(to.split(\"/\"));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n   if (fromParts[i] !== toParts[i]) {\n    samePartsLength = i;\n    break;\n   }\n  }\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n   outputParts.push(\"..\");\n  }\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join(\"/\");\n }\n};\n\nvar TTY = {\n ttys: [],\n init: function() {},\n shutdown: function() {},\n register: function(dev, ops) {\n  TTY.ttys[dev] = {\n   input: [],\n   output: [],\n   ops: ops\n  };\n  FS.registerDevice(dev, TTY.stream_ops);\n },\n stream_ops: {\n  open: function(stream) {\n   var tty = TTY.ttys[stream.node.rdev];\n   if (!tty) {\n    throw new FS.ErrnoError(43);\n   }\n   stream.tty = tty;\n   stream.seekable = false;\n  },\n  close: function(stream) {\n   stream.tty.ops.flush(stream.tty);\n  },\n  flush: function(stream) {\n   stream.tty.ops.flush(stream.tty);\n  },\n  read: function(stream, buffer, offset, length, pos) {\n   if (!stream.tty || !stream.tty.ops.get_char) {\n    throw new FS.ErrnoError(60);\n   }\n   var bytesRead = 0;\n   for (var i = 0; i < length; i++) {\n    var result;\n    try {\n     result = stream.tty.ops.get_char(stream.tty);\n    } catch (e) {\n     throw new FS.ErrnoError(29);\n    }\n    if (result === undefined && bytesRead === 0) {\n     throw new FS.ErrnoError(6);\n    }\n    if (result === null || result === undefined) break;\n    bytesRead++;\n    buffer[offset + i] = result;\n   }\n   if (bytesRead) {\n    stream.node.timestamp = Date.now();\n   }\n   return bytesRead;\n  },\n  write: function(stream, buffer, offset, length, pos) {\n   if (!stream.tty || !stream.tty.ops.put_char) {\n    throw new FS.ErrnoError(60);\n   }\n   try {\n    for (var i = 0; i < length; i++) {\n     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n    }\n   } catch (e) {\n    throw new FS.ErrnoError(29);\n   }\n   if (length) {\n    stream.node.timestamp = Date.now();\n   }\n   return i;\n  }\n },\n default_tty_ops: {\n  get_char: function(tty) {\n   if (!tty.input.length) {\n    var result = null;\n    if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n     result = window.prompt(\"Input: \");\n     if (result !== null) {\n      result += \"\\n\";\n     }\n    } else if (typeof readline == \"function\") {\n     result = readline();\n     if (result !== null) {\n      result += \"\\n\";\n     }\n    }\n    if (!result) {\n     return null;\n    }\n    tty.input = intArrayFromString(result, true);\n   }\n   return tty.input.shift();\n  },\n  put_char: function(tty, val) {\n   if (val === null || val === 10) {\n    out(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   } else {\n    if (val != 0) tty.output.push(val);\n   }\n  },\n  flush: function(tty) {\n   if (tty.output && tty.output.length > 0) {\n    out(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   }\n  }\n },\n default_tty1_ops: {\n  put_char: function(tty, val) {\n   if (val === null || val === 10) {\n    err(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   } else {\n    if (val != 0) tty.output.push(val);\n   }\n  },\n  flush: function(tty) {\n   if (tty.output && tty.output.length > 0) {\n    err(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   }\n  }\n }\n};\n\nfunction zeroMemory(address, size) {\n HEAPU8.fill(0, address, address + size);\n}\n\nfunction alignMemory(size, alignment) {\n assert(alignment, \"alignment argument is required\");\n return Math.ceil(size / alignment) * alignment;\n}\n\nfunction mmapAlloc(size) {\n abort(\"internal error: mmapAlloc called but `memalign` native symbol not exported\");\n}\n\nvar MEMFS = {\n ops_table: null,\n mount: function(mount) {\n  return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n },\n createNode: function(parent, name, mode, dev) {\n  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n   throw new FS.ErrnoError(63);\n  }\n  if (!MEMFS.ops_table) {\n   MEMFS.ops_table = {\n    dir: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr,\n      lookup: MEMFS.node_ops.lookup,\n      mknod: MEMFS.node_ops.mknod,\n      rename: MEMFS.node_ops.rename,\n      unlink: MEMFS.node_ops.unlink,\n      rmdir: MEMFS.node_ops.rmdir,\n      readdir: MEMFS.node_ops.readdir,\n      symlink: MEMFS.node_ops.symlink\n     },\n     stream: {\n      llseek: MEMFS.stream_ops.llseek\n     }\n    },\n    file: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr\n     },\n     stream: {\n      llseek: MEMFS.stream_ops.llseek,\n      read: MEMFS.stream_ops.read,\n      write: MEMFS.stream_ops.write,\n      allocate: MEMFS.stream_ops.allocate,\n      mmap: MEMFS.stream_ops.mmap,\n      msync: MEMFS.stream_ops.msync\n     }\n    },\n    link: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr,\n      readlink: MEMFS.node_ops.readlink\n     },\n     stream: {}\n    },\n    chrdev: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr\n     },\n     stream: FS.chrdev_stream_ops\n    }\n   };\n  }\n  var node = FS.createNode(parent, name, mode, dev);\n  if (FS.isDir(node.mode)) {\n   node.node_ops = MEMFS.ops_table.dir.node;\n   node.stream_ops = MEMFS.ops_table.dir.stream;\n   node.contents = {};\n  } else if (FS.isFile(node.mode)) {\n   node.node_ops = MEMFS.ops_table.file.node;\n   node.stream_ops = MEMFS.ops_table.file.stream;\n   node.usedBytes = 0;\n   node.contents = null;\n  } else if (FS.isLink(node.mode)) {\n   node.node_ops = MEMFS.ops_table.link.node;\n   node.stream_ops = MEMFS.ops_table.link.stream;\n  } else if (FS.isChrdev(node.mode)) {\n   node.node_ops = MEMFS.ops_table.chrdev.node;\n   node.stream_ops = MEMFS.ops_table.chrdev.stream;\n  }\n  node.timestamp = Date.now();\n  if (parent) {\n   parent.contents[name] = node;\n   parent.timestamp = node.timestamp;\n  }\n  return node;\n },\n getFileDataAsTypedArray: function(node) {\n  if (!node.contents) return new Uint8Array(0);\n  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n  return new Uint8Array(node.contents);\n },\n expandFileStorage: function(node, newCapacity) {\n  var prevCapacity = node.contents ? node.contents.length : 0;\n  if (prevCapacity >= newCapacity) return;\n  var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n  newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n  var oldContents = node.contents;\n  node.contents = new Uint8Array(newCapacity);\n  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n },\n resizeFileStorage: function(node, newSize) {\n  if (node.usedBytes == newSize) return;\n  if (newSize == 0) {\n   node.contents = null;\n   node.usedBytes = 0;\n  } else {\n   var oldContents = node.contents;\n   node.contents = new Uint8Array(newSize);\n   if (oldContents) {\n    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n   }\n   node.usedBytes = newSize;\n  }\n },\n node_ops: {\n  getattr: function(node) {\n   var attr = {};\n   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n   attr.ino = node.id;\n   attr.mode = node.mode;\n   attr.nlink = 1;\n   attr.uid = 0;\n   attr.gid = 0;\n   attr.rdev = node.rdev;\n   if (FS.isDir(node.mode)) {\n    attr.size = 4096;\n   } else if (FS.isFile(node.mode)) {\n    attr.size = node.usedBytes;\n   } else if (FS.isLink(node.mode)) {\n    attr.size = node.link.length;\n   } else {\n    attr.size = 0;\n   }\n   attr.atime = new Date(node.timestamp);\n   attr.mtime = new Date(node.timestamp);\n   attr.ctime = new Date(node.timestamp);\n   attr.blksize = 4096;\n   attr.blocks = Math.ceil(attr.size / attr.blksize);\n   return attr;\n  },\n  setattr: function(node, attr) {\n   if (attr.mode !== undefined) {\n    node.mode = attr.mode;\n   }\n   if (attr.timestamp !== undefined) {\n    node.timestamp = attr.timestamp;\n   }\n   if (attr.size !== undefined) {\n    MEMFS.resizeFileStorage(node, attr.size);\n   }\n  },\n  lookup: function(parent, name) {\n   throw FS.genericErrors[44];\n  },\n  mknod: function(parent, name, mode, dev) {\n   return MEMFS.createNode(parent, name, mode, dev);\n  },\n  rename: function(old_node, new_dir, new_name) {\n   if (FS.isDir(old_node.mode)) {\n    var new_node;\n    try {\n     new_node = FS.lookupNode(new_dir, new_name);\n    } catch (e) {}\n    if (new_node) {\n     for (var i in new_node.contents) {\n      throw new FS.ErrnoError(55);\n     }\n    }\n   }\n   delete old_node.parent.contents[old_node.name];\n   old_node.parent.timestamp = Date.now();\n   old_node.name = new_name;\n   new_dir.contents[new_name] = old_node;\n   new_dir.timestamp = old_node.parent.timestamp;\n   old_node.parent = new_dir;\n  },\n  unlink: function(parent, name) {\n   delete parent.contents[name];\n   parent.timestamp = Date.now();\n  },\n  rmdir: function(parent, name) {\n   var node = FS.lookupNode(parent, name);\n   for (var i in node.contents) {\n    throw new FS.ErrnoError(55);\n   }\n   delete parent.contents[name];\n   parent.timestamp = Date.now();\n  },\n  readdir: function(node) {\n   var entries = [ \".\", \"..\" ];\n   for (var key in node.contents) {\n    if (!node.contents.hasOwnProperty(key)) {\n     continue;\n    }\n    entries.push(key);\n   }\n   return entries;\n  },\n  symlink: function(parent, newname, oldpath) {\n   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n   node.link = oldpath;\n   return node;\n  },\n  readlink: function(node) {\n   if (!FS.isLink(node.mode)) {\n    throw new FS.ErrnoError(28);\n   }\n   return node.link;\n  }\n },\n stream_ops: {\n  read: function(stream, buffer, offset, length, position) {\n   var contents = stream.node.contents;\n   if (position >= stream.node.usedBytes) return 0;\n   var size = Math.min(stream.node.usedBytes - position, length);\n   assert(size >= 0);\n   if (size > 8 && contents.subarray) {\n    buffer.set(contents.subarray(position, position + size), offset);\n   } else {\n    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n   }\n   return size;\n  },\n  write: function(stream, buffer, offset, length, position, canOwn) {\n   assert(!(buffer instanceof ArrayBuffer));\n   if (!length) return 0;\n   var node = stream.node;\n   node.timestamp = Date.now();\n   if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n    if (canOwn) {\n     assert(position === 0, \"canOwn must imply no weird position inside the file\");\n     node.contents = buffer.subarray(offset, offset + length);\n     node.usedBytes = length;\n     return length;\n    } else if (node.usedBytes === 0 && position === 0) {\n     node.contents = buffer.slice(offset, offset + length);\n     node.usedBytes = length;\n     return length;\n    } else if (position + length <= node.usedBytes) {\n     node.contents.set(buffer.subarray(offset, offset + length), position);\n     return length;\n    }\n   }\n   MEMFS.expandFileStorage(node, position + length);\n   if (node.contents.subarray && buffer.subarray) {\n    node.contents.set(buffer.subarray(offset, offset + length), position);\n   } else {\n    for (var i = 0; i < length; i++) {\n     node.contents[position + i] = buffer[offset + i];\n    }\n   }\n   node.usedBytes = Math.max(node.usedBytes, position + length);\n   return length;\n  },\n  llseek: function(stream, offset, whence) {\n   var position = offset;\n   if (whence === 1) {\n    position += stream.position;\n   } else if (whence === 2) {\n    if (FS.isFile(stream.node.mode)) {\n     position += stream.node.usedBytes;\n    }\n   }\n   if (position < 0) {\n    throw new FS.ErrnoError(28);\n   }\n   return position;\n  },\n  allocate: function(stream, offset, length) {\n   MEMFS.expandFileStorage(stream.node, offset + length);\n   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n  },\n  mmap: function(stream, address, length, position, prot, flags) {\n   if (address !== 0) {\n    throw new FS.ErrnoError(28);\n   }\n   if (!FS.isFile(stream.node.mode)) {\n    throw new FS.ErrnoError(43);\n   }\n   var ptr;\n   var allocated;\n   var contents = stream.node.contents;\n   if (!(flags & 2) && contents.buffer === buffer) {\n    allocated = false;\n    ptr = contents.byteOffset;\n   } else {\n    if (position > 0 || position + length < contents.length) {\n     if (contents.subarray) {\n      contents = contents.subarray(position, position + length);\n     } else {\n      contents = Array.prototype.slice.call(contents, position, position + length);\n     }\n    }\n    allocated = true;\n    ptr = mmapAlloc(length);\n    if (!ptr) {\n     throw new FS.ErrnoError(48);\n    }\n    HEAP8.set(contents, ptr);\n   }\n   return {\n    ptr: ptr,\n    allocated: allocated\n   };\n  },\n  msync: function(stream, buffer, offset, length, mmapFlags) {\n   if (!FS.isFile(stream.node.mode)) {\n    throw new FS.ErrnoError(43);\n   }\n   if (mmapFlags & 2) {\n    return 0;\n   }\n   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n   return 0;\n  }\n }\n};\n\nfunction asyncLoad(url, onload, onerror, noRunDep) {\n var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\n readAsync(url, function(arrayBuffer) {\n  assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n  onload(new Uint8Array(arrayBuffer));\n  if (dep) removeRunDependency(dep);\n }, function(event) {\n  if (onerror) {\n   onerror();\n  } else {\n   throw 'Loading data file \"' + url + '\" failed.';\n  }\n });\n if (dep) addRunDependency(dep);\n}\n\nvar ERRNO_MESSAGES = {\n 0: \"Success\",\n 1: \"Arg list too long\",\n 2: \"Permission denied\",\n 3: \"Address already in use\",\n 4: \"Address not available\",\n 5: \"Address family not supported by protocol family\",\n 6: \"No more processes\",\n 7: \"Socket already connected\",\n 8: \"Bad file number\",\n 9: \"Trying to read unreadable message\",\n 10: \"Mount device busy\",\n 11: \"Operation canceled\",\n 12: \"No children\",\n 13: \"Connection aborted\",\n 14: \"Connection refused\",\n 15: \"Connection reset by peer\",\n 16: \"File locking deadlock error\",\n 17: \"Destination address required\",\n 18: \"Math arg out of domain of func\",\n 19: \"Quota exceeded\",\n 20: \"File exists\",\n 21: \"Bad address\",\n 22: \"File too large\",\n 23: \"Host is unreachable\",\n 24: \"Identifier removed\",\n 25: \"Illegal byte sequence\",\n 26: \"Connection already in progress\",\n 27: \"Interrupted system call\",\n 28: \"Invalid argument\",\n 29: \"I/O error\",\n 30: \"Socket is already connected\",\n 31: \"Is a directory\",\n 32: \"Too many symbolic links\",\n 33: \"Too many open files\",\n 34: \"Too many links\",\n 35: \"Message too long\",\n 36: \"Multihop attempted\",\n 37: \"File or path name too long\",\n 38: \"Network interface is not configured\",\n 39: \"Connection reset by network\",\n 40: \"Network is unreachable\",\n 41: \"Too many open files in system\",\n 42: \"No buffer space available\",\n 43: \"No such device\",\n 44: \"No such file or directory\",\n 45: \"Exec format error\",\n 46: \"No record locks available\",\n 47: \"The link has been severed\",\n 48: \"Not enough core\",\n 49: \"No message of desired type\",\n 50: \"Protocol not available\",\n 51: \"No space left on device\",\n 52: \"Function not implemented\",\n 53: \"Socket is not connected\",\n 54: \"Not a directory\",\n 55: \"Directory not empty\",\n 56: \"State not recoverable\",\n 57: \"Socket operation on non-socket\",\n 59: \"Not a typewriter\",\n 60: \"No such device or address\",\n 61: \"Value too large for defined data type\",\n 62: \"Previous owner died\",\n 63: \"Not super-user\",\n 64: \"Broken pipe\",\n 65: \"Protocol error\",\n 66: \"Unknown protocol\",\n 67: \"Protocol wrong type for socket\",\n 68: \"Math result not representable\",\n 69: \"Read only file system\",\n 70: \"Illegal seek\",\n 71: \"No such process\",\n 72: \"Stale file handle\",\n 73: \"Connection timed out\",\n 74: \"Text file busy\",\n 75: \"Cross-device link\",\n 100: \"Device not a stream\",\n 101: \"Bad font file fmt\",\n 102: \"Invalid slot\",\n 103: \"Invalid request code\",\n 104: \"No anode\",\n 105: \"Block device required\",\n 106: \"Channel number out of range\",\n 107: \"Level 3 halted\",\n 108: \"Level 3 reset\",\n 109: \"Link number out of range\",\n 110: \"Protocol driver not attached\",\n 111: \"No CSI structure available\",\n 112: \"Level 2 halted\",\n 113: \"Invalid exchange\",\n 114: \"Invalid request descriptor\",\n 115: \"Exchange full\",\n 116: \"No data (for no delay io)\",\n 117: \"Timer expired\",\n 118: \"Out of streams resources\",\n 119: \"Machine is not on the network\",\n 120: \"Package not installed\",\n 121: \"The object is remote\",\n 122: \"Advertise error\",\n 123: \"Srmount error\",\n 124: \"Communication error on send\",\n 125: \"Cross mount point (not really error)\",\n 126: \"Given log. name not unique\",\n 127: \"f.d. invalid for this operation\",\n 128: \"Remote address changed\",\n 129: \"Can   access a needed shared lib\",\n 130: \"Accessing a corrupted shared lib\",\n 131: \".lib section in a.out corrupted\",\n 132: \"Attempting to link in too many libs\",\n 133: \"Attempting to exec a shared library\",\n 135: \"Streams pipe error\",\n 136: \"Too many users\",\n 137: \"Socket type not supported\",\n 138: \"Not supported\",\n 139: \"Protocol family not supported\",\n 140: \"Can't send after socket shutdown\",\n 141: \"Too many references\",\n 142: \"Host is down\",\n 148: \"No medium (in tape drive)\",\n 156: \"Level 2 not synchronized\"\n};\n\nvar ERRNO_CODES = {};\n\nvar FS = {\n root: null,\n mounts: [],\n devices: {},\n streams: [],\n nextInode: 1,\n nameTable: null,\n currentPath: \"/\",\n initialized: false,\n ignorePermissions: true,\n ErrnoError: null,\n genericErrors: {},\n filesystems: null,\n syncFSRequests: 0,\n lookupPath: function(path, opts) {\n  path = PATH_FS.resolve(FS.cwd(), path);\n  opts = opts || {};\n  if (!path) return {\n   path: \"\",\n   node: null\n  };\n  var defaults = {\n   follow_mount: true,\n   recurse_count: 0\n  };\n  for (var key in defaults) {\n   if (opts[key] === undefined) {\n    opts[key] = defaults[key];\n   }\n  }\n  if (opts.recurse_count > 8) {\n   throw new FS.ErrnoError(32);\n  }\n  var parts = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\n   return !!p;\n  }), false);\n  var current = FS.root;\n  var current_path = \"/\";\n  for (var i = 0; i < parts.length; i++) {\n   var islast = i === parts.length - 1;\n   if (islast && opts.parent) {\n    break;\n   }\n   current = FS.lookupNode(current, parts[i]);\n   current_path = PATH.join2(current_path, parts[i]);\n   if (FS.isMountpoint(current)) {\n    if (!islast || islast && opts.follow_mount) {\n     current = current.mounted.root;\n    }\n   }\n   if (!islast || opts.follow) {\n    var count = 0;\n    while (FS.isLink(current.mode)) {\n     var link = FS.readlink(current_path);\n     current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n     var lookup = FS.lookupPath(current_path, {\n      recurse_count: opts.recurse_count\n     });\n     current = lookup.node;\n     if (count++ > 40) {\n      throw new FS.ErrnoError(32);\n     }\n    }\n   }\n  }\n  return {\n   path: current_path,\n   node: current\n  };\n },\n getPath: function(node) {\n  var path;\n  while (true) {\n   if (FS.isRoot(node)) {\n    var mount = node.mount.mountpoint;\n    if (!path) return mount;\n    return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n   }\n   path = path ? node.name + \"/\" + path : node.name;\n   node = node.parent;\n  }\n },\n hashName: function(parentid, name) {\n  var hash = 0;\n  for (var i = 0; i < name.length; i++) {\n   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n  }\n  return (parentid + hash >>> 0) % FS.nameTable.length;\n },\n hashAddNode: function(node) {\n  var hash = FS.hashName(node.parent.id, node.name);\n  node.name_next = FS.nameTable[hash];\n  FS.nameTable[hash] = node;\n },\n hashRemoveNode: function(node) {\n  var hash = FS.hashName(node.parent.id, node.name);\n  if (FS.nameTable[hash] === node) {\n   FS.nameTable[hash] = node.name_next;\n  } else {\n   var current = FS.nameTable[hash];\n   while (current) {\n    if (current.name_next === node) {\n     current.name_next = node.name_next;\n     break;\n    }\n    current = current.name_next;\n   }\n  }\n },\n lookupNode: function(parent, name) {\n  var errCode = FS.mayLookup(parent);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode, parent);\n  }\n  var hash = FS.hashName(parent.id, name);\n  for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n   var nodeName = node.name;\n   if (node.parent.id === parent.id && nodeName === name) {\n    return node;\n   }\n  }\n  return FS.lookup(parent, name);\n },\n createNode: function(parent, name, mode, rdev) {\n  assert(typeof parent === \"object\");\n  var node = new FS.FSNode(parent, name, mode, rdev);\n  FS.hashAddNode(node);\n  return node;\n },\n destroyNode: function(node) {\n  FS.hashRemoveNode(node);\n },\n isRoot: function(node) {\n  return node === node.parent;\n },\n isMountpoint: function(node) {\n  return !!node.mounted;\n },\n isFile: function(mode) {\n  return (mode & 61440) === 32768;\n },\n isDir: function(mode) {\n  return (mode & 61440) === 16384;\n },\n isLink: function(mode) {\n  return (mode & 61440) === 40960;\n },\n isChrdev: function(mode) {\n  return (mode & 61440) === 8192;\n },\n isBlkdev: function(mode) {\n  return (mode & 61440) === 24576;\n },\n isFIFO: function(mode) {\n  return (mode & 61440) === 4096;\n },\n isSocket: function(mode) {\n  return (mode & 49152) === 49152;\n },\n flagModes: {\n  \"r\": 0,\n  \"r+\": 2,\n  \"w\": 577,\n  \"w+\": 578,\n  \"a\": 1089,\n  \"a+\": 1090\n },\n modeStringToFlags: function(str) {\n  var flags = FS.flagModes[str];\n  if (typeof flags === \"undefined\") {\n   throw new Error(\"Unknown file open mode: \" + str);\n  }\n  return flags;\n },\n flagsToPermissionString: function(flag) {\n  var perms = [ \"r\", \"w\", \"rw\" ][flag & 3];\n  if (flag & 512) {\n   perms += \"w\";\n  }\n  return perms;\n },\n nodePermissions: function(node, perms) {\n  if (FS.ignorePermissions) {\n   return 0;\n  }\n  if (perms.includes(\"r\") && !(node.mode & 292)) {\n   return 2;\n  } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n   return 2;\n  } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n   return 2;\n  }\n  return 0;\n },\n mayLookup: function(dir) {\n  var errCode = FS.nodePermissions(dir, \"x\");\n  if (errCode) return errCode;\n  if (!dir.node_ops.lookup) return 2;\n  return 0;\n },\n mayCreate: function(dir, name) {\n  try {\n   var node = FS.lookupNode(dir, name);\n   return 20;\n  } catch (e) {}\n  return FS.nodePermissions(dir, \"wx\");\n },\n mayDelete: function(dir, name, isdir) {\n  var node;\n  try {\n   node = FS.lookupNode(dir, name);\n  } catch (e) {\n   return e.errno;\n  }\n  var errCode = FS.nodePermissions(dir, \"wx\");\n  if (errCode) {\n   return errCode;\n  }\n  if (isdir) {\n   if (!FS.isDir(node.mode)) {\n    return 54;\n   }\n   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n    return 10;\n   }\n  } else {\n   if (FS.isDir(node.mode)) {\n    return 31;\n   }\n  }\n  return 0;\n },\n mayOpen: function(node, flags) {\n  if (!node) {\n   return 44;\n  }\n  if (FS.isLink(node.mode)) {\n   return 32;\n  } else if (FS.isDir(node.mode)) {\n   if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n    return 31;\n   }\n  }\n  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n },\n MAX_OPEN_FDS: 4096,\n nextfd: function(fd_start, fd_end) {\n  fd_start = fd_start || 0;\n  fd_end = fd_end || FS.MAX_OPEN_FDS;\n  for (var fd = fd_start; fd <= fd_end; fd++) {\n   if (!FS.streams[fd]) {\n    return fd;\n   }\n  }\n  throw new FS.ErrnoError(33);\n },\n getStream: function(fd) {\n  return FS.streams[fd];\n },\n createStream: function(stream, fd_start, fd_end) {\n  if (!FS.FSStream) {\n   FS.FSStream = function() {};\n   FS.FSStream.prototype = {\n    object: {\n     get: function() {\n      return this.node;\n     },\n     set: function(val) {\n      this.node = val;\n     }\n    },\n    isRead: {\n     get: function() {\n      return (this.flags & 2097155) !== 1;\n     }\n    },\n    isWrite: {\n     get: function() {\n      return (this.flags & 2097155) !== 0;\n     }\n    },\n    isAppend: {\n     get: function() {\n      return this.flags & 1024;\n     }\n    }\n   };\n  }\n  var newStream = new FS.FSStream();\n  for (var p in stream) {\n   newStream[p] = stream[p];\n  }\n  stream = newStream;\n  var fd = FS.nextfd(fd_start, fd_end);\n  stream.fd = fd;\n  FS.streams[fd] = stream;\n  return stream;\n },\n closeStream: function(fd) {\n  FS.streams[fd] = null;\n },\n chrdev_stream_ops: {\n  open: function(stream) {\n   var device = FS.getDevice(stream.node.rdev);\n   stream.stream_ops = device.stream_ops;\n   if (stream.stream_ops.open) {\n    stream.stream_ops.open(stream);\n   }\n  },\n  llseek: function() {\n   throw new FS.ErrnoError(70);\n  }\n },\n major: function(dev) {\n  return dev >> 8;\n },\n minor: function(dev) {\n  return dev & 255;\n },\n makedev: function(ma, mi) {\n  return ma << 8 | mi;\n },\n registerDevice: function(dev, ops) {\n  FS.devices[dev] = {\n   stream_ops: ops\n  };\n },\n getDevice: function(dev) {\n  return FS.devices[dev];\n },\n getMounts: function(mount) {\n  var mounts = [];\n  var check = [ mount ];\n  while (check.length) {\n   var m = check.pop();\n   mounts.push(m);\n   check.push.apply(check, m.mounts);\n  }\n  return mounts;\n },\n syncfs: function(populate, callback) {\n  if (typeof populate === \"function\") {\n   callback = populate;\n   populate = false;\n  }\n  FS.syncFSRequests++;\n  if (FS.syncFSRequests > 1) {\n   err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n  }\n  var mounts = FS.getMounts(FS.root.mount);\n  var completed = 0;\n  function doCallback(errCode) {\n   assert(FS.syncFSRequests > 0);\n   FS.syncFSRequests--;\n   return callback(errCode);\n  }\n  function done(errCode) {\n   if (errCode) {\n    if (!done.errored) {\n     done.errored = true;\n     return doCallback(errCode);\n    }\n    return;\n   }\n   if (++completed >= mounts.length) {\n    doCallback(null);\n   }\n  }\n  mounts.forEach(function(mount) {\n   if (!mount.type.syncfs) {\n    return done(null);\n   }\n   mount.type.syncfs(mount, populate, done);\n  });\n },\n mount: function(type, opts, mountpoint) {\n  if (typeof type === \"string\") {\n   throw type;\n  }\n  var root = mountpoint === \"/\";\n  var pseudo = !mountpoint;\n  var node;\n  if (root && FS.root) {\n   throw new FS.ErrnoError(10);\n  } else if (!root && !pseudo) {\n   var lookup = FS.lookupPath(mountpoint, {\n    follow_mount: false\n   });\n   mountpoint = lookup.path;\n   node = lookup.node;\n   if (FS.isMountpoint(node)) {\n    throw new FS.ErrnoError(10);\n   }\n   if (!FS.isDir(node.mode)) {\n    throw new FS.ErrnoError(54);\n   }\n  }\n  var mount = {\n   type: type,\n   opts: opts,\n   mountpoint: mountpoint,\n   mounts: []\n  };\n  var mountRoot = type.mount(mount);\n  mountRoot.mount = mount;\n  mount.root = mountRoot;\n  if (root) {\n   FS.root = mountRoot;\n  } else if (node) {\n   node.mounted = mount;\n   if (node.mount) {\n    node.mount.mounts.push(mount);\n   }\n  }\n  return mountRoot;\n },\n unmount: function(mountpoint) {\n  var lookup = FS.lookupPath(mountpoint, {\n   follow_mount: false\n  });\n  if (!FS.isMountpoint(lookup.node)) {\n   throw new FS.ErrnoError(28);\n  }\n  var node = lookup.node;\n  var mount = node.mounted;\n  var mounts = FS.getMounts(mount);\n  Object.keys(FS.nameTable).forEach(function(hash) {\n   var current = FS.nameTable[hash];\n   while (current) {\n    var next = current.name_next;\n    if (mounts.includes(current.mount)) {\n     FS.destroyNode(current);\n    }\n    current = next;\n   }\n  });\n  node.mounted = null;\n  var idx = node.mount.mounts.indexOf(mount);\n  assert(idx !== -1);\n  node.mount.mounts.splice(idx, 1);\n },\n lookup: function(parent, name) {\n  return parent.node_ops.lookup(parent, name);\n },\n mknod: function(path, mode, dev) {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  if (!name || name === \".\" || name === \"..\") {\n   throw new FS.ErrnoError(28);\n  }\n  var errCode = FS.mayCreate(parent, name);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.mknod) {\n   throw new FS.ErrnoError(63);\n  }\n  return parent.node_ops.mknod(parent, name, mode, dev);\n },\n create: function(path, mode) {\n  mode = mode !== undefined ? mode : 438;\n  mode &= 4095;\n  mode |= 32768;\n  return FS.mknod(path, mode, 0);\n },\n mkdir: function(path, mode) {\n  mode = mode !== undefined ? mode : 511;\n  mode &= 511 | 512;\n  mode |= 16384;\n  return FS.mknod(path, mode, 0);\n },\n mkdirTree: function(path, mode) {\n  var dirs = path.split(\"/\");\n  var d = \"\";\n  for (var i = 0; i < dirs.length; ++i) {\n   if (!dirs[i]) continue;\n   d += \"/\" + dirs[i];\n   try {\n    FS.mkdir(d, mode);\n   } catch (e) {\n    if (e.errno != 20) throw e;\n   }\n  }\n },\n mkdev: function(path, mode, dev) {\n  if (typeof dev === \"undefined\") {\n   dev = mode;\n   mode = 438;\n  }\n  mode |= 8192;\n  return FS.mknod(path, mode, dev);\n },\n symlink: function(oldpath, newpath) {\n  if (!PATH_FS.resolve(oldpath)) {\n   throw new FS.ErrnoError(44);\n  }\n  var lookup = FS.lookupPath(newpath, {\n   parent: true\n  });\n  var parent = lookup.node;\n  if (!parent) {\n   throw new FS.ErrnoError(44);\n  }\n  var newname = PATH.basename(newpath);\n  var errCode = FS.mayCreate(parent, newname);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.symlink) {\n   throw new FS.ErrnoError(63);\n  }\n  return parent.node_ops.symlink(parent, newname, oldpath);\n },\n rename: function(old_path, new_path) {\n  var old_dirname = PATH.dirname(old_path);\n  var new_dirname = PATH.dirname(new_path);\n  var old_name = PATH.basename(old_path);\n  var new_name = PATH.basename(new_path);\n  var lookup, old_dir, new_dir;\n  lookup = FS.lookupPath(old_path, {\n   parent: true\n  });\n  old_dir = lookup.node;\n  lookup = FS.lookupPath(new_path, {\n   parent: true\n  });\n  new_dir = lookup.node;\n  if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n  if (old_dir.mount !== new_dir.mount) {\n   throw new FS.ErrnoError(75);\n  }\n  var old_node = FS.lookupNode(old_dir, old_name);\n  var relative = PATH_FS.relative(old_path, new_dirname);\n  if (relative.charAt(0) !== \".\") {\n   throw new FS.ErrnoError(28);\n  }\n  relative = PATH_FS.relative(new_path, old_dirname);\n  if (relative.charAt(0) !== \".\") {\n   throw new FS.ErrnoError(55);\n  }\n  var new_node;\n  try {\n   new_node = FS.lookupNode(new_dir, new_name);\n  } catch (e) {}\n  if (old_node === new_node) {\n   return;\n  }\n  var isdir = FS.isDir(old_node.mode);\n  var errCode = FS.mayDelete(old_dir, old_name, isdir);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!old_dir.node_ops.rename) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n   throw new FS.ErrnoError(10);\n  }\n  if (new_dir !== old_dir) {\n   errCode = FS.nodePermissions(old_dir, \"w\");\n   if (errCode) {\n    throw new FS.ErrnoError(errCode);\n   }\n  }\n  FS.hashRemoveNode(old_node);\n  try {\n   old_dir.node_ops.rename(old_node, new_dir, new_name);\n  } catch (e) {\n   throw e;\n  } finally {\n   FS.hashAddNode(old_node);\n  }\n },\n rmdir: function(path) {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  var node = FS.lookupNode(parent, name);\n  var errCode = FS.mayDelete(parent, name, true);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.rmdir) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(node)) {\n   throw new FS.ErrnoError(10);\n  }\n  parent.node_ops.rmdir(parent, name);\n  FS.destroyNode(node);\n },\n readdir: function(path) {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  if (!node.node_ops.readdir) {\n   throw new FS.ErrnoError(54);\n  }\n  return node.node_ops.readdir(node);\n },\n unlink: function(path) {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  var node = FS.lookupNode(parent, name);\n  var errCode = FS.mayDelete(parent, name, false);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.unlink) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(node)) {\n   throw new FS.ErrnoError(10);\n  }\n  parent.node_ops.unlink(parent, name);\n  FS.destroyNode(node);\n },\n readlink: function(path) {\n  var lookup = FS.lookupPath(path);\n  var link = lookup.node;\n  if (!link) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!link.node_ops.readlink) {\n   throw new FS.ErrnoError(28);\n  }\n  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n },\n stat: function(path, dontFollow) {\n  var lookup = FS.lookupPath(path, {\n   follow: !dontFollow\n  });\n  var node = lookup.node;\n  if (!node) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!node.node_ops.getattr) {\n   throw new FS.ErrnoError(63);\n  }\n  return node.node_ops.getattr(node);\n },\n lstat: function(path) {\n  return FS.stat(path, true);\n },\n chmod: function(path, mode, dontFollow) {\n  var node;\n  if (typeof path === \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontFollow\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  node.node_ops.setattr(node, {\n   mode: mode & 4095 | node.mode & ~4095,\n   timestamp: Date.now()\n  });\n },\n lchmod: function(path, mode) {\n  FS.chmod(path, mode, true);\n },\n fchmod: function(fd, mode) {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  FS.chmod(stream.node, mode);\n },\n chown: function(path, uid, gid, dontFollow) {\n  var node;\n  if (typeof path === \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontFollow\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  node.node_ops.setattr(node, {\n   timestamp: Date.now()\n  });\n },\n lchown: function(path, uid, gid) {\n  FS.chown(path, uid, gid, true);\n },\n fchown: function(fd, uid, gid) {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  FS.chown(stream.node, uid, gid);\n },\n truncate: function(path, len) {\n  if (len < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  var node;\n  if (typeof path === \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: true\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isDir(node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!FS.isFile(node.mode)) {\n   throw new FS.ErrnoError(28);\n  }\n  var errCode = FS.nodePermissions(node, \"w\");\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  node.node_ops.setattr(node, {\n   size: len,\n   timestamp: Date.now()\n  });\n },\n ftruncate: function(fd, len) {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(28);\n  }\n  FS.truncate(stream.node, len);\n },\n utime: function(path, atime, mtime) {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  node.node_ops.setattr(node, {\n   timestamp: Math.max(atime, mtime)\n  });\n },\n open: function(path, flags, mode, fd_start, fd_end) {\n  if (path === \"\") {\n   throw new FS.ErrnoError(44);\n  }\n  flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n  mode = typeof mode === \"undefined\" ? 438 : mode;\n  if (flags & 64) {\n   mode = mode & 4095 | 32768;\n  } else {\n   mode = 0;\n  }\n  var node;\n  if (typeof path === \"object\") {\n   node = path;\n  } else {\n   path = PATH.normalize(path);\n   try {\n    var lookup = FS.lookupPath(path, {\n     follow: !(flags & 131072)\n    });\n    node = lookup.node;\n   } catch (e) {}\n  }\n  var created = false;\n  if (flags & 64) {\n   if (node) {\n    if (flags & 128) {\n     throw new FS.ErrnoError(20);\n    }\n   } else {\n    node = FS.mknod(path, mode, 0);\n    created = true;\n   }\n  }\n  if (!node) {\n   throw new FS.ErrnoError(44);\n  }\n  if (FS.isChrdev(node.mode)) {\n   flags &= ~512;\n  }\n  if (flags & 65536 && !FS.isDir(node.mode)) {\n   throw new FS.ErrnoError(54);\n  }\n  if (!created) {\n   var errCode = FS.mayOpen(node, flags);\n   if (errCode) {\n    throw new FS.ErrnoError(errCode);\n   }\n  }\n  if (flags & 512) {\n   FS.truncate(node, 0);\n  }\n  flags &= ~(128 | 512 | 131072);\n  var stream = FS.createStream({\n   node: node,\n   path: FS.getPath(node),\n   flags: flags,\n   seekable: true,\n   position: 0,\n   stream_ops: node.stream_ops,\n   ungotten: [],\n   error: false\n  }, fd_start, fd_end);\n  if (stream.stream_ops.open) {\n   stream.stream_ops.open(stream);\n  }\n  if (Module[\"logReadFiles\"] && !(flags & 1)) {\n   if (!FS.readFiles) FS.readFiles = {};\n   if (!(path in FS.readFiles)) {\n    FS.readFiles[path] = 1;\n   }\n  }\n  return stream;\n },\n close: function(stream) {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (stream.getdents) stream.getdents = null;\n  try {\n   if (stream.stream_ops.close) {\n    stream.stream_ops.close(stream);\n   }\n  } catch (e) {\n   throw e;\n  } finally {\n   FS.closeStream(stream.fd);\n  }\n  stream.fd = null;\n },\n isClosed: function(stream) {\n  return stream.fd === null;\n },\n llseek: function(stream, offset, whence) {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (!stream.seekable || !stream.stream_ops.llseek) {\n   throw new FS.ErrnoError(70);\n  }\n  if (whence != 0 && whence != 1 && whence != 2) {\n   throw new FS.ErrnoError(28);\n  }\n  stream.position = stream.stream_ops.llseek(stream, offset, whence);\n  stream.ungotten = [];\n  return stream.position;\n },\n read: function(stream, buffer, offset, length, position) {\n  if (length < 0 || position < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 1) {\n   throw new FS.ErrnoError(8);\n  }\n  if (FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!stream.stream_ops.read) {\n   throw new FS.ErrnoError(28);\n  }\n  var seeking = typeof position !== \"undefined\";\n  if (!seeking) {\n   position = stream.position;\n  } else if (!stream.seekable) {\n   throw new FS.ErrnoError(70);\n  }\n  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n  if (!seeking) stream.position += bytesRead;\n  return bytesRead;\n },\n write: function(stream, buffer, offset, length, position, canOwn) {\n  if (length < 0 || position < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(8);\n  }\n  if (FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!stream.stream_ops.write) {\n   throw new FS.ErrnoError(28);\n  }\n  if (stream.seekable && stream.flags & 1024) {\n   FS.llseek(stream, 0, 2);\n  }\n  var seeking = typeof position !== \"undefined\";\n  if (!seeking) {\n   position = stream.position;\n  } else if (!stream.seekable) {\n   throw new FS.ErrnoError(70);\n  }\n  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n  if (!seeking) stream.position += bytesWritten;\n  return bytesWritten;\n },\n allocate: function(stream, offset, length) {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (offset < 0 || length <= 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(8);\n  }\n  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(43);\n  }\n  if (!stream.stream_ops.allocate) {\n   throw new FS.ErrnoError(138);\n  }\n  stream.stream_ops.allocate(stream, offset, length);\n },\n mmap: function(stream, address, length, position, prot, flags) {\n  if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n   throw new FS.ErrnoError(2);\n  }\n  if ((stream.flags & 2097155) === 1) {\n   throw new FS.ErrnoError(2);\n  }\n  if (!stream.stream_ops.mmap) {\n   throw new FS.ErrnoError(43);\n  }\n  return stream.stream_ops.mmap(stream, address, length, position, prot, flags);\n },\n msync: function(stream, buffer, offset, length, mmapFlags) {\n  if (!stream || !stream.stream_ops.msync) {\n   return 0;\n  }\n  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n },\n munmap: function(stream) {\n  return 0;\n },\n ioctl: function(stream, cmd, arg) {\n  if (!stream.stream_ops.ioctl) {\n   throw new FS.ErrnoError(59);\n  }\n  return stream.stream_ops.ioctl(stream, cmd, arg);\n },\n readFile: function(path, opts) {\n  opts = opts || {};\n  opts.flags = opts.flags || 0;\n  opts.encoding = opts.encoding || \"binary\";\n  if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n   throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n  }\n  var ret;\n  var stream = FS.open(path, opts.flags);\n  var stat = FS.stat(path);\n  var length = stat.size;\n  var buf = new Uint8Array(length);\n  FS.read(stream, buf, 0, length, 0);\n  if (opts.encoding === \"utf8\") {\n   ret = UTF8ArrayToString(buf, 0);\n  } else if (opts.encoding === \"binary\") {\n   ret = buf;\n  }\n  FS.close(stream);\n  return ret;\n },\n writeFile: function(path, data, opts) {\n  opts = opts || {};\n  opts.flags = opts.flags || 577;\n  var stream = FS.open(path, opts.flags, opts.mode);\n  if (typeof data === \"string\") {\n   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n   FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n  } else if (ArrayBuffer.isView(data)) {\n   FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n  } else {\n   throw new Error(\"Unsupported data type\");\n  }\n  FS.close(stream);\n },\n cwd: function() {\n  return FS.currentPath;\n },\n chdir: function(path) {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  if (lookup.node === null) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!FS.isDir(lookup.node.mode)) {\n   throw new FS.ErrnoError(54);\n  }\n  var errCode = FS.nodePermissions(lookup.node, \"x\");\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  FS.currentPath = lookup.path;\n },\n createDefaultDirectories: function() {\n  FS.mkdir(\"/tmp\");\n  FS.mkdir(\"/home\");\n  FS.mkdir(\"/home/web_user\");\n },\n createDefaultDevices: function() {\n  FS.mkdir(\"/dev\");\n  FS.registerDevice(FS.makedev(1, 3), {\n   read: function() {\n    return 0;\n   },\n   write: function(stream, buffer, offset, length, pos) {\n    return length;\n   }\n  });\n  FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n  FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n  FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n  var random_device = getRandomDevice();\n  FS.createDevice(\"/dev\", \"random\", random_device);\n  FS.createDevice(\"/dev\", \"urandom\", random_device);\n  FS.mkdir(\"/dev/shm\");\n  FS.mkdir(\"/dev/shm/tmp\");\n },\n createSpecialDirectories: function() {\n  FS.mkdir(\"/proc\");\n  var proc_self = FS.mkdir(\"/proc/self\");\n  FS.mkdir(\"/proc/self/fd\");\n  FS.mount({\n   mount: function() {\n    var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n    node.node_ops = {\n     lookup: function(parent, name) {\n      var fd = +name;\n      var stream = FS.getStream(fd);\n      if (!stream) throw new FS.ErrnoError(8);\n      var ret = {\n       parent: null,\n       mount: {\n        mountpoint: \"fake\"\n       },\n       node_ops: {\n        readlink: function() {\n         return stream.path;\n        }\n       }\n      };\n      ret.parent = ret;\n      return ret;\n     }\n    };\n    return node;\n   }\n  }, {}, \"/proc/self/fd\");\n },\n createStandardStreams: function() {\n  if (Module[\"stdin\"]) {\n   FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n  } else {\n   FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n  }\n  if (Module[\"stdout\"]) {\n   FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n  } else {\n   FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n  }\n  if (Module[\"stderr\"]) {\n   FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n  } else {\n   FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n  }\n  var stdin = FS.open(\"/dev/stdin\", 0);\n  var stdout = FS.open(\"/dev/stdout\", 1);\n  var stderr = FS.open(\"/dev/stderr\", 1);\n  assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\n  assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\n  assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\n },\n ensureErrnoError: function() {\n  if (FS.ErrnoError) return;\n  FS.ErrnoError = function ErrnoError(errno, node) {\n   this.node = node;\n   this.setErrno = function(errno) {\n    this.errno = errno;\n    for (var key in ERRNO_CODES) {\n     if (ERRNO_CODES[key] === errno) {\n      this.code = key;\n      break;\n     }\n    }\n   };\n   this.setErrno(errno);\n   this.message = ERRNO_MESSAGES[errno];\n   if (this.stack) {\n    Object.defineProperty(this, \"stack\", {\n     value: new Error().stack,\n     writable: true\n    });\n    this.stack = demangleAll(this.stack);\n   }\n  };\n  FS.ErrnoError.prototype = new Error();\n  FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n  [ 44 ].forEach(function(code) {\n   FS.genericErrors[code] = new FS.ErrnoError(code);\n   FS.genericErrors[code].stack = \"<generic error, no stack>\";\n  });\n },\n staticInit: function() {\n  FS.ensureErrnoError();\n  FS.nameTable = new Array(4096);\n  FS.mount(MEMFS, {}, \"/\");\n  FS.createDefaultDirectories();\n  FS.createDefaultDevices();\n  FS.createSpecialDirectories();\n  FS.filesystems = {\n   \"MEMFS\": MEMFS\n  };\n },\n init: function(input, output, error) {\n  assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\n  FS.init.initialized = true;\n  FS.ensureErrnoError();\n  Module[\"stdin\"] = input || Module[\"stdin\"];\n  Module[\"stdout\"] = output || Module[\"stdout\"];\n  Module[\"stderr\"] = error || Module[\"stderr\"];\n  FS.createStandardStreams();\n },\n quit: function() {\n  FS.init.initialized = false;\n  var fflush = Module[\"_fflush\"];\n  if (fflush) fflush(0);\n  for (var i = 0; i < FS.streams.length; i++) {\n   var stream = FS.streams[i];\n   if (!stream) {\n    continue;\n   }\n   FS.close(stream);\n  }\n },\n getMode: function(canRead, canWrite) {\n  var mode = 0;\n  if (canRead) mode |= 292 | 73;\n  if (canWrite) mode |= 146;\n  return mode;\n },\n findObject: function(path, dontResolveLastLink) {\n  var ret = FS.analyzePath(path, dontResolveLastLink);\n  if (ret.exists) {\n   return ret.object;\n  } else {\n   return null;\n  }\n },\n analyzePath: function(path, dontResolveLastLink) {\n  try {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontResolveLastLink\n   });\n   path = lookup.path;\n  } catch (e) {}\n  var ret = {\n   isRoot: false,\n   exists: false,\n   error: 0,\n   name: null,\n   path: null,\n   object: null,\n   parentExists: false,\n   parentPath: null,\n   parentObject: null\n  };\n  try {\n   var lookup = FS.lookupPath(path, {\n    parent: true\n   });\n   ret.parentExists = true;\n   ret.parentPath = lookup.path;\n   ret.parentObject = lookup.node;\n   ret.name = PATH.basename(path);\n   lookup = FS.lookupPath(path, {\n    follow: !dontResolveLastLink\n   });\n   ret.exists = true;\n   ret.path = lookup.path;\n   ret.object = lookup.node;\n   ret.name = lookup.node.name;\n   ret.isRoot = lookup.path === \"/\";\n  } catch (e) {\n   ret.error = e.errno;\n  }\n  return ret;\n },\n createPath: function(parent, path, canRead, canWrite) {\n  parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n  var parts = path.split(\"/\").reverse();\n  while (parts.length) {\n   var part = parts.pop();\n   if (!part) continue;\n   var current = PATH.join2(parent, part);\n   try {\n    FS.mkdir(current);\n   } catch (e) {}\n   parent = current;\n  }\n  return current;\n },\n createFile: function(parent, name, properties, canRead, canWrite) {\n  var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n  var mode = FS.getMode(canRead, canWrite);\n  return FS.create(path, mode);\n },\n createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {\n  var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n  var mode = FS.getMode(canRead, canWrite);\n  var node = FS.create(path, mode);\n  if (data) {\n   if (typeof data === \"string\") {\n    var arr = new Array(data.length);\n    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n    data = arr;\n   }\n   FS.chmod(node, mode | 146);\n   var stream = FS.open(node, 577);\n   FS.write(stream, data, 0, data.length, 0, canOwn);\n   FS.close(stream);\n   FS.chmod(node, mode);\n  }\n  return node;\n },\n createDevice: function(parent, name, input, output) {\n  var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n  var mode = FS.getMode(!!input, !!output);\n  if (!FS.createDevice.major) FS.createDevice.major = 64;\n  var dev = FS.makedev(FS.createDevice.major++, 0);\n  FS.registerDevice(dev, {\n   open: function(stream) {\n    stream.seekable = false;\n   },\n   close: function(stream) {\n    if (output && output.buffer && output.buffer.length) {\n     output(10);\n    }\n   },\n   read: function(stream, buffer, offset, length, pos) {\n    var bytesRead = 0;\n    for (var i = 0; i < length; i++) {\n     var result;\n     try {\n      result = input();\n     } catch (e) {\n      throw new FS.ErrnoError(29);\n     }\n     if (result === undefined && bytesRead === 0) {\n      throw new FS.ErrnoError(6);\n     }\n     if (result === null || result === undefined) break;\n     bytesRead++;\n     buffer[offset + i] = result;\n    }\n    if (bytesRead) {\n     stream.node.timestamp = Date.now();\n    }\n    return bytesRead;\n   },\n   write: function(stream, buffer, offset, length, pos) {\n    for (var i = 0; i < length; i++) {\n     try {\n      output(buffer[offset + i]);\n     } catch (e) {\n      throw new FS.ErrnoError(29);\n     }\n    }\n    if (length) {\n     stream.node.timestamp = Date.now();\n    }\n    return i;\n   }\n  });\n  return FS.mkdev(path, mode, dev);\n },\n forceLoadFile: function(obj) {\n  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n  if (typeof XMLHttpRequest !== \"undefined\") {\n   throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n  } else if (read_) {\n   try {\n    obj.contents = intArrayFromString(read_(obj.url), true);\n    obj.usedBytes = obj.contents.length;\n   } catch (e) {\n    throw new FS.ErrnoError(29);\n   }\n  } else {\n   throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n  }\n },\n createLazyFile: function(parent, name, url, canRead, canWrite) {\n  function LazyUint8Array() {\n   this.lengthKnown = false;\n   this.chunks = [];\n  }\n  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n   if (idx > this.length - 1 || idx < 0) {\n    return undefined;\n   }\n   var chunkOffset = idx % this.chunkSize;\n   var chunkNum = idx / this.chunkSize | 0;\n   return this.getter(chunkNum)[chunkOffset];\n  };\n  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n   this.getter = getter;\n  };\n  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"HEAD\", url, false);\n   xhr.send(null);\n   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n   var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n   var header;\n   var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n   var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n   var chunkSize = 1024 * 1024;\n   if (!hasByteServing) chunkSize = datalength;\n   var doXHR = function(from, to) {\n    if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n    if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n    if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\n    if (xhr.overrideMimeType) {\n     xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n    }\n    xhr.send(null);\n    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n    if (xhr.response !== undefined) {\n     return new Uint8Array(xhr.response || []);\n    } else {\n     return intArrayFromString(xhr.responseText || \"\", true);\n    }\n   };\n   var lazyArray = this;\n   lazyArray.setDataGetter(function(chunkNum) {\n    var start = chunkNum * chunkSize;\n    var end = (chunkNum + 1) * chunkSize - 1;\n    end = Math.min(end, datalength - 1);\n    if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n     lazyArray.chunks[chunkNum] = doXHR(start, end);\n    }\n    if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n    return lazyArray.chunks[chunkNum];\n   });\n   if (usesGzip || !datalength) {\n    chunkSize = datalength = 1;\n    datalength = this.getter(0).length;\n    chunkSize = datalength;\n    out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n   }\n   this._length = datalength;\n   this._chunkSize = chunkSize;\n   this.lengthKnown = true;\n  };\n  if (typeof XMLHttpRequest !== \"undefined\") {\n   if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n   var lazyArray = new LazyUint8Array();\n   Object.defineProperties(lazyArray, {\n    length: {\n     get: function() {\n      if (!this.lengthKnown) {\n       this.cacheLength();\n      }\n      return this._length;\n     }\n    },\n    chunkSize: {\n     get: function() {\n      if (!this.lengthKnown) {\n       this.cacheLength();\n      }\n      return this._chunkSize;\n     }\n    }\n   });\n   var properties = {\n    isDevice: false,\n    contents: lazyArray\n   };\n  } else {\n   var properties = {\n    isDevice: false,\n    url: url\n   };\n  }\n  var node = FS.createFile(parent, name, properties, canRead, canWrite);\n  if (properties.contents) {\n   node.contents = properties.contents;\n  } else if (properties.url) {\n   node.contents = null;\n   node.url = properties.url;\n  }\n  Object.defineProperties(node, {\n   usedBytes: {\n    get: function() {\n     return this.contents.length;\n    }\n   }\n  });\n  var stream_ops = {};\n  var keys = Object.keys(node.stream_ops);\n  keys.forEach(function(key) {\n   var fn = node.stream_ops[key];\n   stream_ops[key] = function forceLoadLazyFile() {\n    FS.forceLoadFile(node);\n    return fn.apply(null, arguments);\n   };\n  });\n  stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n   FS.forceLoadFile(node);\n   var contents = stream.node.contents;\n   if (position >= contents.length) return 0;\n   var size = Math.min(contents.length - position, length);\n   assert(size >= 0);\n   if (contents.slice) {\n    for (var i = 0; i < size; i++) {\n     buffer[offset + i] = contents[position + i];\n    }\n   } else {\n    for (var i = 0; i < size; i++) {\n     buffer[offset + i] = contents.get(position + i);\n    }\n   }\n   return size;\n  };\n  node.stream_ops = stream_ops;\n  return node;\n },\n createPreloadedFile: function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n  Browser.init();\n  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n  var dep = getUniqueRunDependency(\"cp \" + fullname);\n  function processData(byteArray) {\n   function finish(byteArray) {\n    if (preFinish) preFinish();\n    if (!dontCreateFile) {\n     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n    }\n    if (onload) onload();\n    removeRunDependency(dep);\n   }\n   var handled = false;\n   Module[\"preloadPlugins\"].forEach(function(plugin) {\n    if (handled) return;\n    if (plugin[\"canHandle\"](fullname)) {\n     plugin[\"handle\"](byteArray, fullname, finish, function() {\n      if (onerror) onerror();\n      removeRunDependency(dep);\n     });\n     handled = true;\n    }\n   });\n   if (!handled) finish(byteArray);\n  }\n  addRunDependency(dep);\n  if (typeof url == \"string\") {\n   asyncLoad(url, function(byteArray) {\n    processData(byteArray);\n   }, onerror);\n  } else {\n   processData(url);\n  }\n },\n indexedDB: function() {\n  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n },\n DB_NAME: function() {\n  return \"EM_FS_\" + window.location.pathname;\n },\n DB_VERSION: 20,\n DB_STORE_NAME: \"FILE_DATA\",\n saveFilesToDB: function(paths, onload, onerror) {\n  onload = onload || function() {};\n  onerror = onerror || function() {};\n  var indexedDB = FS.indexedDB();\n  try {\n   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n  } catch (e) {\n   return onerror(e);\n  }\n  openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n   out(\"creating db\");\n   var db = openRequest.result;\n   db.createObjectStore(FS.DB_STORE_NAME);\n  };\n  openRequest.onsuccess = function openRequest_onsuccess() {\n   var db = openRequest.result;\n   var transaction = db.transaction([ FS.DB_STORE_NAME ], \"readwrite\");\n   var files = transaction.objectStore(FS.DB_STORE_NAME);\n   var ok = 0, fail = 0, total = paths.length;\n   function finish() {\n    if (fail == 0) onload(); else onerror();\n   }\n   paths.forEach(function(path) {\n    var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n    putRequest.onsuccess = function putRequest_onsuccess() {\n     ok++;\n     if (ok + fail == total) finish();\n    };\n    putRequest.onerror = function putRequest_onerror() {\n     fail++;\n     if (ok + fail == total) finish();\n    };\n   });\n   transaction.onerror = onerror;\n  };\n  openRequest.onerror = onerror;\n },\n loadFilesFromDB: function(paths, onload, onerror) {\n  onload = onload || function() {};\n  onerror = onerror || function() {};\n  var indexedDB = FS.indexedDB();\n  try {\n   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n  } catch (e) {\n   return onerror(e);\n  }\n  openRequest.onupgradeneeded = onerror;\n  openRequest.onsuccess = function openRequest_onsuccess() {\n   var db = openRequest.result;\n   try {\n    var transaction = db.transaction([ FS.DB_STORE_NAME ], \"readonly\");\n   } catch (e) {\n    onerror(e);\n    return;\n   }\n   var files = transaction.objectStore(FS.DB_STORE_NAME);\n   var ok = 0, fail = 0, total = paths.length;\n   function finish() {\n    if (fail == 0) onload(); else onerror();\n   }\n   paths.forEach(function(path) {\n    var getRequest = files.get(path);\n    getRequest.onsuccess = function getRequest_onsuccess() {\n     if (FS.analyzePath(path).exists) {\n      FS.unlink(path);\n     }\n     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n     ok++;\n     if (ok + fail == total) finish();\n    };\n    getRequest.onerror = function getRequest_onerror() {\n     fail++;\n     if (ok + fail == total) finish();\n    };\n   });\n   transaction.onerror = onerror;\n  };\n  openRequest.onerror = onerror;\n },\n absolutePath: function() {\n  abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\n },\n createFolder: function() {\n  abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\n },\n createLink: function() {\n  abort(\"FS.createLink has been removed; use FS.symlink instead\");\n },\n joinPath: function() {\n  abort(\"FS.joinPath has been removed; use PATH.join instead\");\n },\n mmapAlloc: function() {\n  abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\n },\n standardizePath: function() {\n  abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\n }\n};\n\nvar SYSCALLS = {\n mappings: {},\n DEFAULT_POLLMASK: 5,\n umask: 511,\n calculateAt: function(dirfd, path, allowEmpty) {\n  if (path[0] === \"/\") {\n   return path;\n  }\n  var dir;\n  if (dirfd === -100) {\n   dir = FS.cwd();\n  } else {\n   var dirstream = FS.getStream(dirfd);\n   if (!dirstream) throw new FS.ErrnoError(8);\n   dir = dirstream.path;\n  }\n  if (path.length == 0) {\n   if (!allowEmpty) {\n    throw new FS.ErrnoError(44);\n   }\n   return dir;\n  }\n  return PATH.join2(dir, path);\n },\n doStat: function(func, path, buf) {\n  try {\n   var stat = func(path);\n  } catch (e) {\n   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n    return -54;\n   }\n   throw e;\n  }\n  SAFE_HEAP_STORE(buf | 0, stat.dev | 0, 4);\n  SAFE_HEAP_STORE(buf + 4 | 0, 0 | 0, 4);\n  SAFE_HEAP_STORE(buf + 8 | 0, stat.ino | 0, 4);\n  SAFE_HEAP_STORE(buf + 12 | 0, stat.mode | 0, 4);\n  SAFE_HEAP_STORE(buf + 16 | 0, stat.nlink | 0, 4);\n  SAFE_HEAP_STORE(buf + 20 | 0, stat.uid | 0, 4);\n  SAFE_HEAP_STORE(buf + 24 | 0, stat.gid | 0, 4);\n  SAFE_HEAP_STORE(buf + 28 | 0, stat.rdev | 0, 4);\n  SAFE_HEAP_STORE(buf + 32 | 0, 0 | 0, 4);\n  tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  SAFE_HEAP_STORE(buf + 40 | 0, tempI64[0] | 0, 4), SAFE_HEAP_STORE(buf + 44 | 0, tempI64[1] | 0, 4);\n  SAFE_HEAP_STORE(buf + 48 | 0, 4096 | 0, 4);\n  SAFE_HEAP_STORE(buf + 52 | 0, stat.blocks | 0, 4);\n  SAFE_HEAP_STORE(buf + 56 | 0, stat.atime.getTime() / 1e3 | 0 | 0, 4);\n  SAFE_HEAP_STORE(buf + 60 | 0, 0 | 0, 4);\n  SAFE_HEAP_STORE(buf + 64 | 0, stat.mtime.getTime() / 1e3 | 0 | 0, 4);\n  SAFE_HEAP_STORE(buf + 68 | 0, 0 | 0, 4);\n  SAFE_HEAP_STORE(buf + 72 | 0, stat.ctime.getTime() / 1e3 | 0 | 0, 4);\n  SAFE_HEAP_STORE(buf + 76 | 0, 0 | 0, 4);\n  tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  SAFE_HEAP_STORE(buf + 80 | 0, tempI64[0] | 0, 4), SAFE_HEAP_STORE(buf + 84 | 0, tempI64[1] | 0, 4);\n  return 0;\n },\n doMsync: function(addr, stream, len, flags, offset) {\n  var buffer = HEAPU8.slice(addr, addr + len);\n  FS.msync(stream, buffer, offset, len, flags);\n },\n doMkdir: function(path, mode) {\n  path = PATH.normalize(path);\n  if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n  FS.mkdir(path, mode, 0);\n  return 0;\n },\n doMknod: function(path, mode, dev) {\n  switch (mode & 61440) {\n  case 32768:\n  case 8192:\n  case 24576:\n  case 4096:\n  case 49152:\n   break;\n\n  default:\n   return -28;\n  }\n  FS.mknod(path, mode, dev);\n  return 0;\n },\n doReadlink: function(path, buf, bufsize) {\n  if (bufsize <= 0) return -28;\n  var ret = FS.readlink(path);\n  var len = Math.min(bufsize, lengthBytesUTF8(ret));\n  var endChar = SAFE_HEAP_LOAD(buf + len, 1, 0);\n  stringToUTF8(ret, buf, bufsize + 1);\n  SAFE_HEAP_STORE(buf + len, endChar, 1);\n  return len;\n },\n doAccess: function(path, amode) {\n  if (amode & ~7) {\n   return -28;\n  }\n  var node;\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  node = lookup.node;\n  if (!node) {\n   return -44;\n  }\n  var perms = \"\";\n  if (amode & 4) perms += \"r\";\n  if (amode & 2) perms += \"w\";\n  if (amode & 1) perms += \"x\";\n  if (perms && FS.nodePermissions(node, perms)) {\n   return -2;\n  }\n  return 0;\n },\n doDup: function(path, flags, suggestFD) {\n  var suggest = FS.getStream(suggestFD);\n  if (suggest) FS.close(suggest);\n  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n },\n doReadv: function(stream, iov, iovcnt, offset) {\n  var ret = 0;\n  for (var i = 0; i < iovcnt; i++) {\n   var ptr = SAFE_HEAP_LOAD(iov + i * 8 | 0, 4, 0) | 0;\n   var len = SAFE_HEAP_LOAD(iov + (i * 8 + 4) | 0, 4, 0) | 0;\n   var curr = FS.read(stream, HEAP8, ptr, len, offset);\n   if (curr < 0) return -1;\n   ret += curr;\n   if (curr < len) break;\n  }\n  return ret;\n },\n doWritev: function(stream, iov, iovcnt, offset) {\n  var ret = 0;\n  for (var i = 0; i < iovcnt; i++) {\n   var ptr = SAFE_HEAP_LOAD(iov + i * 8 | 0, 4, 0) | 0;\n   var len = SAFE_HEAP_LOAD(iov + (i * 8 + 4) | 0, 4, 0) | 0;\n   var curr = FS.write(stream, HEAP8, ptr, len, offset);\n   if (curr < 0) return -1;\n   ret += curr;\n  }\n  return ret;\n },\n varargs: undefined,\n get: function() {\n  assert(SYSCALLS.varargs != undefined);\n  SYSCALLS.varargs += 4;\n  var ret = SAFE_HEAP_LOAD(SYSCALLS.varargs - 4 | 0, 4, 0) | 0;\n  return ret;\n },\n getStr: function(ptr) {\n  var ret = UTF8ToString(ptr);\n  return ret;\n },\n getStreamFromFD: function(fd) {\n  var stream = FS.getStream(fd);\n  if (!stream) throw new FS.ErrnoError(8);\n  return stream;\n },\n get64: function(low, high) {\n  if (low >= 0) assert(high === 0); else assert(high === -1);\n  return low;\n }\n};\n\nfunction ___sys_fcntl64(fd, cmd, varargs) {\n SYSCALLS.varargs = varargs;\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  switch (cmd) {\n  case 0:\n   {\n    var arg = SYSCALLS.get();\n    if (arg < 0) {\n     return -28;\n    }\n    var newStream;\n    newStream = FS.open(stream.path, stream.flags, 0, arg);\n    return newStream.fd;\n   }\n\n  case 1:\n  case 2:\n   return 0;\n\n  case 3:\n   return stream.flags;\n\n  case 4:\n   {\n    var arg = SYSCALLS.get();\n    stream.flags |= arg;\n    return 0;\n   }\n\n  case 12:\n   {\n    var arg = SYSCALLS.get();\n    var offset = 0;\n    SAFE_HEAP_STORE(arg + offset | 0, 2 | 0, 2);\n    return 0;\n   }\n\n  case 13:\n  case 14:\n   return 0;\n\n  case 16:\n  case 8:\n   return -28;\n\n  case 9:\n   setErrNo(28);\n   return -1;\n\n  default:\n   {\n    return -28;\n   }\n  }\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return -e.errno;\n }\n}\n\nfunction ___sys_fstat64(fd, buf) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  return SYSCALLS.doStat(FS.stat, stream.path, buf);\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return -e.errno;\n }\n}\n\nfunction ___sys_ioctl(fd, op, varargs) {\n SYSCALLS.varargs = varargs;\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  switch (op) {\n  case 21509:\n  case 21505:\n   {\n    if (!stream.tty) return -59;\n    return 0;\n   }\n\n  case 21510:\n  case 21511:\n  case 21512:\n  case 21506:\n  case 21507:\n  case 21508:\n   {\n    if (!stream.tty) return -59;\n    return 0;\n   }\n\n  case 21519:\n   {\n    if (!stream.tty) return -59;\n    var argp = SYSCALLS.get();\n    SAFE_HEAP_STORE(argp | 0, 0 | 0, 4);\n    return 0;\n   }\n\n  case 21520:\n   {\n    if (!stream.tty) return -59;\n    return -28;\n   }\n\n  case 21531:\n   {\n    var argp = SYSCALLS.get();\n    return FS.ioctl(stream, op, argp);\n   }\n\n  case 21523:\n   {\n    if (!stream.tty) return -59;\n    return 0;\n   }\n\n  case 21524:\n   {\n    if (!stream.tty) return -59;\n    return 0;\n   }\n\n  default:\n   abort(\"bad ioctl syscall \" + op);\n  }\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return -e.errno;\n }\n}\n\nfunction ___sys_open(path, flags, varargs) {\n SYSCALLS.varargs = varargs;\n try {\n  var pathname = SYSCALLS.getStr(path);\n  var mode = varargs ? SYSCALLS.get() : 0;\n  var stream = FS.open(pathname, flags, mode);\n  return stream.fd;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return -e.errno;\n }\n}\n\nfunction ___sys_stat64(path, buf) {\n try {\n  path = SYSCALLS.getStr(path);\n  return SYSCALLS.doStat(FS.stat, path, buf);\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return -e.errno;\n }\n}\n\nfunction _abort() {\n abort(\"native code called abort()\");\n}\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n HEAPU8.copyWithin(dest, src, src + num);\n}\n\nfunction abortOnCannotGrowMemory(requestedSize) {\n abort(\"Cannot enlarge memory arrays to size \" + requestedSize + \" bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value \" + HEAP8.length + \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \");\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n var oldSize = HEAPU8.length;\n requestedSize = requestedSize >>> 0;\n abortOnCannotGrowMemory(requestedSize);\n}\n\nvar ENV = {};\n\nfunction getExecutableName() {\n return thisProgram || \"./this.program\";\n}\n\nfunction getEnvStrings() {\n if (!getEnvStrings.strings) {\n  var lang = (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n  var env = {\n   \"USER\": \"web_user\",\n   \"LOGNAME\": \"web_user\",\n   \"PATH\": \"/\",\n   \"PWD\": \"/\",\n   \"HOME\": \"/home/web_user\",\n   \"LANG\": lang,\n   \"_\": getExecutableName()\n  };\n  for (var x in ENV) {\n   if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];\n  }\n  var strings = [];\n  for (var x in env) {\n   strings.push(x + \"=\" + env[x]);\n  }\n  getEnvStrings.strings = strings;\n }\n return getEnvStrings.strings;\n}\n\nfunction _environ_get(__environ, environ_buf) {\n var bufSize = 0;\n getEnvStrings().forEach(function(string, i) {\n  var ptr = environ_buf + bufSize;\n  SAFE_HEAP_STORE(__environ + i * 4 | 0, ptr | 0, 4);\n  writeAsciiToMemory(string, ptr);\n  bufSize += string.length + 1;\n });\n return 0;\n}\n\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\n var strings = getEnvStrings();\n SAFE_HEAP_STORE(penviron_count | 0, strings.length | 0, 4);\n var bufSize = 0;\n strings.forEach(function(string) {\n  bufSize += string.length + 1;\n });\n SAFE_HEAP_STORE(penviron_buf_size | 0, bufSize | 0, 4);\n return 0;\n}\n\nfunction _exit(status) {\n exit(status);\n}\n\nfunction _fd_close(fd) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  FS.close(stream);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return e.errno;\n }\n}\n\nfunction _fd_fdstat_get(fd, pbuf) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;\n  SAFE_HEAP_STORE(pbuf | 0, type | 0, 1);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return e.errno;\n }\n}\n\nfunction _fd_read(fd, iov, iovcnt, pnum) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n  SAFE_HEAP_STORE(pnum | 0, num | 0, 4);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return e.errno;\n }\n}\n\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var HIGH_OFFSET = 4294967296;\n  var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\n  var DOUBLE_LIMIT = 9007199254740992;\n  if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\n   return -61;\n  }\n  FS.llseek(stream, offset, whence);\n  tempI64 = [ stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  SAFE_HEAP_STORE(newOffset | 0, tempI64[0] | 0, 4), SAFE_HEAP_STORE(newOffset + 4 | 0, tempI64[1] | 0, 4);\n  if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return e.errno;\n }\n}\n\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n  SAFE_HEAP_STORE(pnum | 0, num | 0, 4);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n  return e.errno;\n }\n}\n\nfunction _setTempRet0(val) {\n setTempRet0(val);\n}\n\nfunction __isLeapYear(year) {\n return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nfunction __arraySum(array, index) {\n var sum = 0;\n for (var i = 0; i <= index; sum += array[i++]) {}\n return sum;\n}\n\nvar __MONTH_DAYS_LEAP = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\nvar __MONTH_DAYS_REGULAR = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\nfunction __addDays(date, days) {\n var newDate = new Date(date.getTime());\n while (days > 0) {\n  var leap = __isLeapYear(newDate.getFullYear());\n  var currentMonth = newDate.getMonth();\n  var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n  if (days > daysInCurrentMonth - newDate.getDate()) {\n   days -= daysInCurrentMonth - newDate.getDate() + 1;\n   newDate.setDate(1);\n   if (currentMonth < 11) {\n    newDate.setMonth(currentMonth + 1);\n   } else {\n    newDate.setMonth(0);\n    newDate.setFullYear(newDate.getFullYear() + 1);\n   }\n  } else {\n   newDate.setDate(newDate.getDate() + days);\n   return newDate;\n  }\n }\n return newDate;\n}\n\nfunction _strftime(s, maxsize, format, tm) {\n var tm_zone = SAFE_HEAP_LOAD(tm + 40 | 0, 4, 0) | 0;\n var date = {\n  tm_sec: SAFE_HEAP_LOAD(tm | 0, 4, 0) | 0,\n  tm_min: SAFE_HEAP_LOAD(tm + 4 | 0, 4, 0) | 0,\n  tm_hour: SAFE_HEAP_LOAD(tm + 8 | 0, 4, 0) | 0,\n  tm_mday: SAFE_HEAP_LOAD(tm + 12 | 0, 4, 0) | 0,\n  tm_mon: SAFE_HEAP_LOAD(tm + 16 | 0, 4, 0) | 0,\n  tm_year: SAFE_HEAP_LOAD(tm + 20 | 0, 4, 0) | 0,\n  tm_wday: SAFE_HEAP_LOAD(tm + 24 | 0, 4, 0) | 0,\n  tm_yday: SAFE_HEAP_LOAD(tm + 28 | 0, 4, 0) | 0,\n  tm_isdst: SAFE_HEAP_LOAD(tm + 32 | 0, 4, 0) | 0,\n  tm_gmtoff: SAFE_HEAP_LOAD(tm + 36 | 0, 4, 0) | 0,\n  tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n };\n var pattern = UTF8ToString(format);\n var EXPANSION_RULES_1 = {\n  \"%c\": \"%a %b %d %H:%M:%S %Y\",\n  \"%D\": \"%m/%d/%y\",\n  \"%F\": \"%Y-%m-%d\",\n  \"%h\": \"%b\",\n  \"%r\": \"%I:%M:%S %p\",\n  \"%R\": \"%H:%M\",\n  \"%T\": \"%H:%M:%S\",\n  \"%x\": \"%m/%d/%y\",\n  \"%X\": \"%H:%M:%S\",\n  \"%Ec\": \"%c\",\n  \"%EC\": \"%C\",\n  \"%Ex\": \"%m/%d/%y\",\n  \"%EX\": \"%H:%M:%S\",\n  \"%Ey\": \"%y\",\n  \"%EY\": \"%Y\",\n  \"%Od\": \"%d\",\n  \"%Oe\": \"%e\",\n  \"%OH\": \"%H\",\n  \"%OI\": \"%I\",\n  \"%Om\": \"%m\",\n  \"%OM\": \"%M\",\n  \"%OS\": \"%S\",\n  \"%Ou\": \"%u\",\n  \"%OU\": \"%U\",\n  \"%OV\": \"%V\",\n  \"%Ow\": \"%w\",\n  \"%OW\": \"%W\",\n  \"%Oy\": \"%y\"\n };\n for (var rule in EXPANSION_RULES_1) {\n  pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n }\n var WEEKDAYS = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ];\n var MONTHS = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ];\n function leadingSomething(value, digits, character) {\n  var str = typeof value === \"number\" ? value.toString() : value || \"\";\n  while (str.length < digits) {\n   str = character[0] + str;\n  }\n  return str;\n }\n function leadingNulls(value, digits) {\n  return leadingSomething(value, digits, \"0\");\n }\n function compareByDay(date1, date2) {\n  function sgn(value) {\n   return value < 0 ? -1 : value > 0 ? 1 : 0;\n  }\n  var compare;\n  if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n   if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n    compare = sgn(date1.getDate() - date2.getDate());\n   }\n  }\n  return compare;\n }\n function getFirstWeekStartDate(janFourth) {\n  switch (janFourth.getDay()) {\n  case 0:\n   return new Date(janFourth.getFullYear() - 1, 11, 29);\n\n  case 1:\n   return janFourth;\n\n  case 2:\n   return new Date(janFourth.getFullYear(), 0, 3);\n\n  case 3:\n   return new Date(janFourth.getFullYear(), 0, 2);\n\n  case 4:\n   return new Date(janFourth.getFullYear(), 0, 1);\n\n  case 5:\n   return new Date(janFourth.getFullYear() - 1, 11, 31);\n\n  case 6:\n   return new Date(janFourth.getFullYear() - 1, 11, 30);\n  }\n }\n function getWeekBasedYear(date) {\n  var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n  var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n  var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n  var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n  var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n  if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n   if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n    return thisDate.getFullYear() + 1;\n   } else {\n    return thisDate.getFullYear();\n   }\n  } else {\n   return thisDate.getFullYear() - 1;\n  }\n }\n var EXPANSION_RULES_2 = {\n  \"%a\": function(date) {\n   return WEEKDAYS[date.tm_wday].substring(0, 3);\n  },\n  \"%A\": function(date) {\n   return WEEKDAYS[date.tm_wday];\n  },\n  \"%b\": function(date) {\n   return MONTHS[date.tm_mon].substring(0, 3);\n  },\n  \"%B\": function(date) {\n   return MONTHS[date.tm_mon];\n  },\n  \"%C\": function(date) {\n   var year = date.tm_year + 1900;\n   return leadingNulls(year / 100 | 0, 2);\n  },\n  \"%d\": function(date) {\n   return leadingNulls(date.tm_mday, 2);\n  },\n  \"%e\": function(date) {\n   return leadingSomething(date.tm_mday, 2, \" \");\n  },\n  \"%g\": function(date) {\n   return getWeekBasedYear(date).toString().substring(2);\n  },\n  \"%G\": function(date) {\n   return getWeekBasedYear(date);\n  },\n  \"%H\": function(date) {\n   return leadingNulls(date.tm_hour, 2);\n  },\n  \"%I\": function(date) {\n   var twelveHour = date.tm_hour;\n   if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12;\n   return leadingNulls(twelveHour, 2);\n  },\n  \"%j\": function(date) {\n   return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n  },\n  \"%m\": function(date) {\n   return leadingNulls(date.tm_mon + 1, 2);\n  },\n  \"%M\": function(date) {\n   return leadingNulls(date.tm_min, 2);\n  },\n  \"%n\": function() {\n   return \"\\n\";\n  },\n  \"%p\": function(date) {\n   if (date.tm_hour >= 0 && date.tm_hour < 12) {\n    return \"AM\";\n   } else {\n    return \"PM\";\n   }\n  },\n  \"%S\": function(date) {\n   return leadingNulls(date.tm_sec, 2);\n  },\n  \"%t\": function() {\n   return \"\\t\";\n  },\n  \"%u\": function(date) {\n   return date.tm_wday || 7;\n  },\n  \"%U\": function(date) {\n   var janFirst = new Date(date.tm_year + 1900, 0, 1);\n   var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n   var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n   if (compareByDay(firstSunday, endDate) < 0) {\n    var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n    var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n    var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n    return leadingNulls(Math.ceil(days / 7), 2);\n   }\n   return compareByDay(firstSunday, janFirst) === 0 ? \"01\" : \"00\";\n  },\n  \"%V\": function(date) {\n   var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\n   var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\n   var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n   var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n   var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n   if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n    return \"53\";\n   }\n   if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n    return \"01\";\n   }\n   var daysDifference;\n   if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\n    daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\n   } else {\n    daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\n   }\n   return leadingNulls(Math.ceil(daysDifference / 7), 2);\n  },\n  \"%w\": function(date) {\n   return date.tm_wday;\n  },\n  \"%W\": function(date) {\n   var janFirst = new Date(date.tm_year, 0, 1);\n   var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n   var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n   if (compareByDay(firstMonday, endDate) < 0) {\n    var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n    var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n    var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n    return leadingNulls(Math.ceil(days / 7), 2);\n   }\n   return compareByDay(firstMonday, janFirst) === 0 ? \"01\" : \"00\";\n  },\n  \"%y\": function(date) {\n   return (date.tm_year + 1900).toString().substring(2);\n  },\n  \"%Y\": function(date) {\n   return date.tm_year + 1900;\n  },\n  \"%z\": function(date) {\n   var off = date.tm_gmtoff;\n   var ahead = off >= 0;\n   off = Math.abs(off) / 60;\n   off = off / 60 * 100 + off % 60;\n   return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n  },\n  \"%Z\": function(date) {\n   return date.tm_zone;\n  },\n  \"%%\": function() {\n   return \"%\";\n  }\n };\n for (var rule in EXPANSION_RULES_2) {\n  if (pattern.includes(rule)) {\n   pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n  }\n }\n var bytes = intArrayFromString(pattern, false);\n if (bytes.length > maxsize) {\n  return 0;\n }\n writeArrayToMemory(bytes, s);\n return bytes.length - 1;\n}\n\nfunction _strftime_l(s, maxsize, format, tm) {\n return _strftime(s, maxsize, format, tm);\n}\n\nvar FSNode = function(parent, name, mode, rdev) {\n if (!parent) {\n  parent = this;\n }\n this.parent = parent;\n this.mount = parent.mount;\n this.mounted = null;\n this.id = FS.nextInode++;\n this.name = name;\n this.mode = mode;\n this.node_ops = {};\n this.stream_ops = {};\n this.rdev = rdev;\n};\n\nvar readMode = 292 | 73;\n\nvar writeMode = 146;\n\nObject.defineProperties(FSNode.prototype, {\n read: {\n  get: function() {\n   return (this.mode & readMode) === readMode;\n  },\n  set: function(val) {\n   val ? this.mode |= readMode : this.mode &= ~readMode;\n  }\n },\n write: {\n  get: function() {\n   return (this.mode & writeMode) === writeMode;\n  },\n  set: function(val) {\n   val ? this.mode |= writeMode : this.mode &= ~writeMode;\n  }\n },\n isFolder: {\n  get: function() {\n   return FS.isDir(this.mode);\n  }\n },\n isDevice: {\n  get: function() {\n   return FS.isChrdev(this.mode);\n  }\n }\n});\n\nFS.FSNode = FSNode;\n\nFS.staticInit();\n\nModule[\"FS_createPath\"] = FS.createPath;\n\nModule[\"FS_createDataFile\"] = FS.createDataFile;\n\nModule[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n\nModule[\"FS_createLazyFile\"] = FS.createLazyFile;\n\nModule[\"FS_createDevice\"] = FS.createDevice;\n\nModule[\"FS_unlink\"] = FS.unlink;\n\nERRNO_CODES = {\n \"EPERM\": 63,\n \"ENOENT\": 44,\n \"ESRCH\": 71,\n \"EINTR\": 27,\n \"EIO\": 29,\n \"ENXIO\": 60,\n \"E2BIG\": 1,\n \"ENOEXEC\": 45,\n \"EBADF\": 8,\n \"ECHILD\": 12,\n \"EAGAIN\": 6,\n \"EWOULDBLOCK\": 6,\n \"ENOMEM\": 48,\n \"EACCES\": 2,\n \"EFAULT\": 21,\n \"ENOTBLK\": 105,\n \"EBUSY\": 10,\n \"EEXIST\": 20,\n \"EXDEV\": 75,\n \"ENODEV\": 43,\n \"ENOTDIR\": 54,\n \"EISDIR\": 31,\n \"EINVAL\": 28,\n \"ENFILE\": 41,\n \"EMFILE\": 33,\n \"ENOTTY\": 59,\n \"ETXTBSY\": 74,\n \"EFBIG\": 22,\n \"ENOSPC\": 51,\n \"ESPIPE\": 70,\n \"EROFS\": 69,\n \"EMLINK\": 34,\n \"EPIPE\": 64,\n \"EDOM\": 18,\n \"ERANGE\": 68,\n \"ENOMSG\": 49,\n \"EIDRM\": 24,\n \"ECHRNG\": 106,\n \"EL2NSYNC\": 156,\n \"EL3HLT\": 107,\n \"EL3RST\": 108,\n \"ELNRNG\": 109,\n \"EUNATCH\": 110,\n \"ENOCSI\": 111,\n \"EL2HLT\": 112,\n \"EDEADLK\": 16,\n \"ENOLCK\": 46,\n \"EBADE\": 113,\n \"EBADR\": 114,\n \"EXFULL\": 115,\n \"ENOANO\": 104,\n \"EBADRQC\": 103,\n \"EBADSLT\": 102,\n \"EDEADLOCK\": 16,\n \"EBFONT\": 101,\n \"ENOSTR\": 100,\n \"ENODATA\": 116,\n \"ETIME\": 117,\n \"ENOSR\": 118,\n \"ENONET\": 119,\n \"ENOPKG\": 120,\n \"EREMOTE\": 121,\n \"ENOLINK\": 47,\n \"EADV\": 122,\n \"ESRMNT\": 123,\n \"ECOMM\": 124,\n \"EPROTO\": 65,\n \"EMULTIHOP\": 36,\n \"EDOTDOT\": 125,\n \"EBADMSG\": 9,\n \"ENOTUNIQ\": 126,\n \"EBADFD\": 127,\n \"EREMCHG\": 128,\n \"ELIBACC\": 129,\n \"ELIBBAD\": 130,\n \"ELIBSCN\": 131,\n \"ELIBMAX\": 132,\n \"ELIBEXEC\": 133,\n \"ENOSYS\": 52,\n \"ENOTEMPTY\": 55,\n \"ENAMETOOLONG\": 37,\n \"ELOOP\": 32,\n \"EOPNOTSUPP\": 138,\n \"EPFNOSUPPORT\": 139,\n \"ECONNRESET\": 15,\n \"ENOBUFS\": 42,\n \"EAFNOSUPPORT\": 5,\n \"EPROTOTYPE\": 67,\n \"ENOTSOCK\": 57,\n \"ENOPROTOOPT\": 50,\n \"ESHUTDOWN\": 140,\n \"ECONNREFUSED\": 14,\n \"EADDRINUSE\": 3,\n \"ECONNABORTED\": 13,\n \"ENETUNREACH\": 40,\n \"ENETDOWN\": 38,\n \"ETIMEDOUT\": 73,\n \"EHOSTDOWN\": 142,\n \"EHOSTUNREACH\": 23,\n \"EINPROGRESS\": 26,\n \"EALREADY\": 7,\n \"EDESTADDRREQ\": 17,\n \"EMSGSIZE\": 35,\n \"EPROTONOSUPPORT\": 66,\n \"ESOCKTNOSUPPORT\": 137,\n \"EADDRNOTAVAIL\": 4,\n \"ENETRESET\": 39,\n \"EISCONN\": 30,\n \"ENOTCONN\": 53,\n \"ETOOMANYREFS\": 141,\n \"EUSERS\": 136,\n \"EDQUOT\": 19,\n \"ESTALE\": 72,\n \"ENOTSUP\": 138,\n \"ENOMEDIUM\": 148,\n \"EILSEQ\": 25,\n \"EOVERFLOW\": 61,\n \"ECANCELED\": 11,\n \"ENOTRECOVERABLE\": 56,\n \"EOWNERDEAD\": 62,\n \"ESTRPIPE\": 135\n};\n\nvar ASSERTIONS = true;\n\nfunction intArrayFromString(stringy, dontAddNull, length) {\n var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n var u8array = new Array(len);\n var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n if (dontAddNull) u8array.length = numBytesWritten;\n return u8array;\n}\n\nfunction intArrayToString(array) {\n var ret = [];\n for (var i = 0; i < array.length; i++) {\n  var chr = array[i];\n  if (chr > 255) {\n   if (ASSERTIONS) {\n    assert(false, \"Character code \" + chr + \" (\" + String.fromCharCode(chr) + \")  at offset \" + i + \" not in 0x00-0xFF.\");\n   }\n   chr &= 255;\n  }\n  ret.push(String.fromCharCode(chr));\n }\n return ret.join(\"\");\n}\n\nvar decodeBase64 = typeof atob === \"function\" ? atob : function(input) {\n var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n var output = \"\";\n var chr1, chr2, chr3;\n var enc1, enc2, enc3, enc4;\n var i = 0;\n input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n do {\n  enc1 = keyStr.indexOf(input.charAt(i++));\n  enc2 = keyStr.indexOf(input.charAt(i++));\n  enc3 = keyStr.indexOf(input.charAt(i++));\n  enc4 = keyStr.indexOf(input.charAt(i++));\n  chr1 = enc1 << 2 | enc2 >> 4;\n  chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n  chr3 = (enc3 & 3) << 6 | enc4;\n  output = output + String.fromCharCode(chr1);\n  if (enc3 !== 64) {\n   output = output + String.fromCharCode(chr2);\n  }\n  if (enc4 !== 64) {\n   output = output + String.fromCharCode(chr3);\n  }\n } while (i < input.length);\n return output;\n};\n\nfunction intArrayFromBase64(s) {\n try {\n  var decoded = decodeBase64(s);\n  var bytes = new Uint8Array(decoded.length);\n  for (var i = 0; i < decoded.length; ++i) {\n   bytes[i] = decoded.charCodeAt(i);\n  }\n  return bytes;\n } catch (_) {\n  throw new Error(\"Converting base64 string to bytes failed.\");\n }\n}\n\nfunction tryParseAsDataURI(filename) {\n if (!isDataURI(filename)) {\n  return;\n }\n return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n}\n\nvar asmLibraryArg = {\n \"__cxa_allocate_exception\": ___cxa_allocate_exception,\n \"__cxa_atexit\": ___cxa_atexit,\n \"__cxa_throw\": ___cxa_throw,\n \"__sys_fcntl64\": ___sys_fcntl64,\n \"__sys_fstat64\": ___sys_fstat64,\n \"__sys_ioctl\": ___sys_ioctl,\n \"__sys_open\": ___sys_open,\n \"__sys_stat64\": ___sys_stat64,\n \"abort\": _abort,\n \"alignfault\": alignfault,\n \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n \"emscripten_resize_heap\": _emscripten_resize_heap,\n \"environ_get\": _environ_get,\n \"environ_sizes_get\": _environ_sizes_get,\n \"exit\": _exit,\n \"fd_close\": _fd_close,\n \"fd_fdstat_get\": _fd_fdstat_get,\n \"fd_read\": _fd_read,\n \"fd_seek\": _fd_seek,\n \"fd_write\": _fd_write,\n \"segfault\": segfault,\n \"setTempRet0\": _setTempRet0,\n \"strftime_l\": _strftime_l\n};\n\nvar asm = createWasm();\n\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = createExportWrapper(\"__wasm_call_ctors\");\n\nvar _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\n\nvar _mecab_new2 = Module[\"_mecab_new2\"] = createExportWrapper(\"mecab_new2\");\n\nvar _mecab_sparse_tostr3 = Module[\"_mecab_sparse_tostr3\"] = createExportWrapper(\"mecab_sparse_tostr3\");\n\nvar _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\");\n\nvar _emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = function() {\n return (_emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = function() {\n return (_emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\n};\n\nvar ___errno_location = Module[\"___errno_location\"] = createExportWrapper(\"__errno_location\");\n\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\");\n\nvar _emscripten_stack_init = Module[\"_emscripten_stack_init\"] = function() {\n return (_emscripten_stack_init = Module[\"_emscripten_stack_init\"] = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = function() {\n return (_emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\n};\n\nvar _sbrk = Module[\"_sbrk\"] = createExportWrapper(\"sbrk\");\n\nvar _emscripten_get_sbrk_ptr = Module[\"_emscripten_get_sbrk_ptr\"] = createExportWrapper(\"emscripten_get_sbrk_ptr\");\n\nvar stackSave = Module[\"stackSave\"] = createExportWrapper(\"stackSave\");\n\nvar stackRestore = Module[\"stackRestore\"] = createExportWrapper(\"stackRestore\");\n\nvar stackAlloc = Module[\"stackAlloc\"] = createExportWrapper(\"stackAlloc\");\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = createExportWrapper(\"dynCall_jiji\");\n\nvar dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = createExportWrapper(\"dynCall_iiiiij\");\n\nvar dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = createExportWrapper(\"dynCall_iiiiijj\");\n\nvar dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = createExportWrapper(\"dynCall_iiiiiijj\");\n\nvar dynCall_viijii = Module[\"dynCall_viijii\"] = createExportWrapper(\"dynCall_viijii\");\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function() {\n abort(\"'intArrayFromString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function() {\n abort(\"'intArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"ccall\"] = ccall;\n\nModule[\"cwrap\"] = cwrap;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function() {\n abort(\"'setValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function() {\n abort(\"'getValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function() {\n abort(\"'allocate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function() {\n abort(\"'UTF8ArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"UTF8ToString\"] = UTF8ToString;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function() {\n abort(\"'stringToUTF8Array' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function() {\n abort(\"'stringToUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"lengthBytesUTF8\"] = lengthBytesUTF8;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() {\n abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function() {\n abort(\"'addOnPreRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function() {\n abort(\"'addOnInit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function() {\n abort(\"'addOnPreMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function() {\n abort(\"'addOnExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function() {\n abort(\"'addOnPostRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function() {\n abort(\"'writeStringToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function() {\n abort(\"'writeArrayToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function() {\n abort(\"'writeAsciiToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"addRunDependency\"] = addRunDependency;\n\nModule[\"removeRunDependency\"] = removeRunDependency;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function() {\n abort(\"'FS_createFolder' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"FS_createPath\"] = FS.createPath;\n\nModule[\"FS_createDataFile\"] = FS.createDataFile;\n\nModule[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n\nModule[\"FS_createLazyFile\"] = FS.createLazyFile;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function() {\n abort(\"'FS_createLink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"FS_createDevice\"] = FS.createDevice;\n\nModule[\"FS_unlink\"] = FS.unlink;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function() {\n abort(\"'getLEB' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function() {\n abort(\"'getFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function() {\n abort(\"'alignFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function() {\n abort(\"'registerFunctions' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function() {\n abort(\"'addFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function() {\n abort(\"'removeFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function() {\n abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function() {\n abort(\"'prettyPrint' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function() {\n abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function() {\n abort(\"'getCompilerSetting' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function() {\n abort(\"'print' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function() {\n abort(\"'printErr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function() {\n abort(\"'getTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function() {\n abort(\"'setTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function() {\n abort(\"'callMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function() {\n abort(\"'abort' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"keepRuntimeAlive\")) Module[\"keepRuntimeAlive\"] = function() {\n abort(\"'keepRuntimeAlive' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"zeroMemory\")) Module[\"zeroMemory\"] = function() {\n abort(\"'zeroMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = function() {\n abort(\"'stringToNewUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setFileTime\")) Module[\"setFileTime\"] = function() {\n abort(\"'setFileTime' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = function() {\n abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = function() {\n abort(\"'emscripten_realloc_buffer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function() {\n abort(\"'ENV' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = function() {\n abort(\"'ERRNO_CODES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = function() {\n abort(\"'ERRNO_MESSAGES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setErrNo\")) Module[\"setErrNo\"] = function() {\n abort(\"'setErrNo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetPton4\")) Module[\"inetPton4\"] = function() {\n abort(\"'inetPton4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetNtop4\")) Module[\"inetNtop4\"] = function() {\n abort(\"'inetNtop4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetPton6\")) Module[\"inetPton6\"] = function() {\n abort(\"'inetPton6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetNtop6\")) Module[\"inetNtop6\"] = function() {\n abort(\"'inetNtop6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readSockaddr\")) Module[\"readSockaddr\"] = function() {\n abort(\"'readSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeSockaddr\")) Module[\"writeSockaddr\"] = function() {\n abort(\"'writeSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = function() {\n abort(\"'DNS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getHostByName\")) Module[\"getHostByName\"] = function() {\n abort(\"'getHostByName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\")) Module[\"GAI_ERRNO_MESSAGES\"] = function() {\n abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = function() {\n abort(\"'Protocols' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = function() {\n abort(\"'Sockets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getRandomDevice\")) Module[\"getRandomDevice\"] = function() {\n abort(\"'getRandomDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"traverseStack\")) Module[\"traverseStack\"] = function() {\n abort(\"'traverseStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = function() {\n abort(\"'UNWIND_CACHE' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgsArray\")) Module[\"readAsmConstArgsArray\"] = function() {\n abort(\"'readAsmConstArgsArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = function() {\n abort(\"'readAsmConstArgs' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"mainThreadEM_ASM\")) Module[\"mainThreadEM_ASM\"] = function() {\n abort(\"'mainThreadEM_ASM' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"jstoi_q\")) Module[\"jstoi_q\"] = function() {\n abort(\"'jstoi_q' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"jstoi_s\")) Module[\"jstoi_s\"] = function() {\n abort(\"'jstoi_s' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getExecutableName\")) Module[\"getExecutableName\"] = function() {\n abort(\"'getExecutableName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"listenOnce\")) Module[\"listenOnce\"] = function() {\n abort(\"'listenOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"autoResumeAudioContext\")) Module[\"autoResumeAudioContext\"] = function() {\n abort(\"'autoResumeAudioContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCallLegacy\")) Module[\"dynCallLegacy\"] = function() {\n abort(\"'dynCallLegacy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getDynCaller\")) Module[\"getDynCaller\"] = function() {\n abort(\"'getDynCaller' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function() {\n abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"callRuntimeCallbacks\")) Module[\"callRuntimeCallbacks\"] = function() {\n abort(\"'callRuntimeCallbacks' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"handleException\")) Module[\"handleException\"] = function() {\n abort(\"'handleException' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePush\")) Module[\"runtimeKeepalivePush\"] = function() {\n abort(\"'runtimeKeepalivePush' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePop\")) Module[\"runtimeKeepalivePop\"] = function() {\n abort(\"'runtimeKeepalivePop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"callUserCallback\")) Module[\"callUserCallback\"] = function() {\n abort(\"'callUserCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"maybeExit\")) Module[\"maybeExit\"] = function() {\n abort(\"'maybeExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"safeSetTimeout\")) Module[\"safeSetTimeout\"] = function() {\n abort(\"'safeSetTimeout' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"asmjsMangle\")) Module[\"asmjsMangle\"] = function() {\n abort(\"'asmjsMangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"asyncLoad\")) Module[\"asyncLoad\"] = function() {\n abort(\"'asyncLoad' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"alignMemory\")) Module[\"alignMemory\"] = function() {\n abort(\"'alignMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"mmapAlloc\")) Module[\"mmapAlloc\"] = function() {\n abort(\"'mmapAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"reallyNegative\")) Module[\"reallyNegative\"] = function() {\n abort(\"'reallyNegative' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"unSign\")) Module[\"unSign\"] = function() {\n abort(\"'unSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"reSign\")) Module[\"reSign\"] = function() {\n abort(\"'reSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"formatString\")) Module[\"formatString\"] = function() {\n abort(\"'formatString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = function() {\n abort(\"'PATH' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = function() {\n abort(\"'PATH_FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = function() {\n abort(\"'SYSCALLS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"syscallMmap2\")) Module[\"syscallMmap2\"] = function() {\n abort(\"'syscallMmap2' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"syscallMunmap\")) Module[\"syscallMunmap\"] = function() {\n abort(\"'syscallMunmap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getSocketFromFD\")) Module[\"getSocketFromFD\"] = function() {\n abort(\"'getSocketFromFD' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getSocketAddress\")) Module[\"getSocketAddress\"] = function() {\n abort(\"'getSocketAddress' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = function() {\n abort(\"'JSEvents' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerKeyEventCallback\")) Module[\"registerKeyEventCallback\"] = function() {\n abort(\"'registerKeyEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"specialHTMLTargets\")) Module[\"specialHTMLTargets\"] = function() {\n abort(\"'specialHTMLTargets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"maybeCStringToJsString\")) Module[\"maybeCStringToJsString\"] = function() {\n abort(\"'maybeCStringToJsString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"findEventTarget\")) Module[\"findEventTarget\"] = function() {\n abort(\"'findEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"findCanvasEventTarget\")) Module[\"findCanvasEventTarget\"] = function() {\n abort(\"'findCanvasEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getBoundingClientRect\")) Module[\"getBoundingClientRect\"] = function() {\n abort(\"'getBoundingClientRect' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillMouseEventData\")) Module[\"fillMouseEventData\"] = function() {\n abort(\"'fillMouseEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerMouseEventCallback\")) Module[\"registerMouseEventCallback\"] = function() {\n abort(\"'registerMouseEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerWheelEventCallback\")) Module[\"registerWheelEventCallback\"] = function() {\n abort(\"'registerWheelEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerUiEventCallback\")) Module[\"registerUiEventCallback\"] = function() {\n abort(\"'registerUiEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFocusEventCallback\")) Module[\"registerFocusEventCallback\"] = function() {\n abort(\"'registerFocusEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceOrientationEventData\")) Module[\"fillDeviceOrientationEventData\"] = function() {\n abort(\"'fillDeviceOrientationEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceOrientationEventCallback\")) Module[\"registerDeviceOrientationEventCallback\"] = function() {\n abort(\"'registerDeviceOrientationEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceMotionEventData\")) Module[\"fillDeviceMotionEventData\"] = function() {\n abort(\"'fillDeviceMotionEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceMotionEventCallback\")) Module[\"registerDeviceMotionEventCallback\"] = function() {\n abort(\"'registerDeviceMotionEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"screenOrientation\")) Module[\"screenOrientation\"] = function() {\n abort(\"'screenOrientation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillOrientationChangeEventData\")) Module[\"fillOrientationChangeEventData\"] = function() {\n abort(\"'fillOrientationChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerOrientationChangeEventCallback\")) Module[\"registerOrientationChangeEventCallback\"] = function() {\n abort(\"'registerOrientationChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillFullscreenChangeEventData\")) Module[\"fillFullscreenChangeEventData\"] = function() {\n abort(\"'fillFullscreenChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFullscreenChangeEventCallback\")) Module[\"registerFullscreenChangeEventCallback\"] = function() {\n abort(\"'registerFullscreenChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerRestoreOldStyle\")) Module[\"registerRestoreOldStyle\"] = function() {\n abort(\"'registerRestoreOldStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"hideEverythingExceptGivenElement\")) Module[\"hideEverythingExceptGivenElement\"] = function() {\n abort(\"'hideEverythingExceptGivenElement' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"restoreHiddenElements\")) Module[\"restoreHiddenElements\"] = function() {\n abort(\"'restoreHiddenElements' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setLetterbox\")) Module[\"setLetterbox\"] = function() {\n abort(\"'setLetterbox' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"currentFullscreenStrategy\")) Module[\"currentFullscreenStrategy\"] = function() {\n abort(\"'currentFullscreenStrategy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"restoreOldWindowedStyle\")) Module[\"restoreOldWindowedStyle\"] = function() {\n abort(\"'restoreOldWindowedStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"softFullscreenResizeWebGLRenderTarget\")) Module[\"softFullscreenResizeWebGLRenderTarget\"] = function() {\n abort(\"'softFullscreenResizeWebGLRenderTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"doRequestFullscreen\")) Module[\"doRequestFullscreen\"] = function() {\n abort(\"'doRequestFullscreen' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillPointerlockChangeEventData\")) Module[\"fillPointerlockChangeEventData\"] = function() {\n abort(\"'fillPointerlockChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockChangeEventCallback\")) Module[\"registerPointerlockChangeEventCallback\"] = function() {\n abort(\"'registerPointerlockChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockErrorEventCallback\")) Module[\"registerPointerlockErrorEventCallback\"] = function() {\n abort(\"'registerPointerlockErrorEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"requestPointerLock\")) Module[\"requestPointerLock\"] = function() {\n abort(\"'requestPointerLock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillVisibilityChangeEventData\")) Module[\"fillVisibilityChangeEventData\"] = function() {\n abort(\"'fillVisibilityChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerVisibilityChangeEventCallback\")) Module[\"registerVisibilityChangeEventCallback\"] = function() {\n abort(\"'registerVisibilityChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerTouchEventCallback\")) Module[\"registerTouchEventCallback\"] = function() {\n abort(\"'registerTouchEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillGamepadEventData\")) Module[\"fillGamepadEventData\"] = function() {\n abort(\"'fillGamepadEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerGamepadEventCallback\")) Module[\"registerGamepadEventCallback\"] = function() {\n abort(\"'registerGamepadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerBeforeUnloadEventCallback\")) Module[\"registerBeforeUnloadEventCallback\"] = function() {\n abort(\"'registerBeforeUnloadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillBatteryEventData\")) Module[\"fillBatteryEventData\"] = function() {\n abort(\"'fillBatteryEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"battery\")) Module[\"battery\"] = function() {\n abort(\"'battery' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerBatteryEventCallback\")) Module[\"registerBatteryEventCallback\"] = function() {\n abort(\"'registerBatteryEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setCanvasElementSize\")) Module[\"setCanvasElementSize\"] = function() {\n abort(\"'setCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getCanvasElementSize\")) Module[\"getCanvasElementSize\"] = function() {\n abort(\"'getCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setImmediateWrapped\")) Module[\"setImmediateWrapped\"] = function() {\n abort(\"'setImmediateWrapped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"clearImmediateWrapped\")) Module[\"clearImmediateWrapped\"] = function() {\n abort(\"'clearImmediateWrapped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"polyfillSetImmediate\")) Module[\"polyfillSetImmediate\"] = function() {\n abort(\"'polyfillSetImmediate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = function() {\n abort(\"'demangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = function() {\n abort(\"'demangleAll' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = function() {\n abort(\"'jsStackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() {\n abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getEnvStrings\")) Module[\"getEnvStrings\"] = function() {\n abort(\"'getEnvStrings' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"checkWasiClock\")) Module[\"checkWasiClock\"] = function() {\n abort(\"'checkWasiClock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = function() {\n abort(\"'writeI53ToI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = function() {\n abort(\"'writeI53ToI64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = function() {\n abort(\"'writeI53ToI64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = function() {\n abort(\"'writeI53ToU64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = function() {\n abort(\"'writeI53ToU64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = function() {\n abort(\"'readI53FromI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = function() {\n abort(\"'readI53FromU64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = function() {\n abort(\"'convertI32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = function() {\n abort(\"'convertU32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"uncaughtExceptionCount\")) Module[\"uncaughtExceptionCount\"] = function() {\n abort(\"'uncaughtExceptionCount' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exceptionLast\")) Module[\"exceptionLast\"] = function() {\n abort(\"'exceptionLast' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exceptionCaught\")) Module[\"exceptionCaught\"] = function() {\n abort(\"'exceptionCaught' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ExceptionInfo\")) Module[\"ExceptionInfo\"] = function() {\n abort(\"'ExceptionInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"CatchInfo\")) Module[\"CatchInfo\"] = function() {\n abort(\"'CatchInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exception_addRef\")) Module[\"exception_addRef\"] = function() {\n abort(\"'exception_addRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exception_decRef\")) Module[\"exception_decRef\"] = function() {\n abort(\"'exception_decRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = function() {\n abort(\"'Browser' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"funcWrappers\")) Module[\"funcWrappers\"] = function() {\n abort(\"'funcWrappers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function() {\n abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setMainLoop\")) Module[\"setMainLoop\"] = function() {\n abort(\"'setMainLoop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"wget\")) Module[\"wget\"] = function() {\n abort(\"'wget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function() {\n abort(\"'FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = function() {\n abort(\"'MEMFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = function() {\n abort(\"'TTY' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = function() {\n abort(\"'PIPEFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = function() {\n abort(\"'SOCKFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"_setNetworkCallback\")) Module[\"_setNetworkCallback\"] = function() {\n abort(\"'_setNetworkCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"tempFixedLengthArray\")) Module[\"tempFixedLengthArray\"] = function() {\n abort(\"'tempFixedLengthArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"miniTempWebGLFloatBuffers\")) Module[\"miniTempWebGLFloatBuffers\"] = function() {\n abort(\"'miniTempWebGLFloatBuffers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"heapObjectForWebGLType\")) Module[\"heapObjectForWebGLType\"] = function() {\n abort(\"'heapObjectForWebGLType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"heapAccessShiftForWebGLHeap\")) Module[\"heapAccessShiftForWebGLHeap\"] = function() {\n abort(\"'heapAccessShiftForWebGLHeap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function() {\n abort(\"'GL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = function() {\n abort(\"'emscriptenWebGLGet' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"computeUnpackAlignedImageSize\")) Module[\"computeUnpackAlignedImageSize\"] = function() {\n abort(\"'computeUnpackAlignedImageSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = function() {\n abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = function() {\n abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"webglGetUniformLocation\")) Module[\"webglGetUniformLocation\"] = function() {\n abort(\"'webglGetUniformLocation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"webglPrepareUniformLocationsBeforeFirstUse\")) Module[\"webglPrepareUniformLocationsBeforeFirstUse\"] = function() {\n abort(\"'webglPrepareUniformLocationsBeforeFirstUse' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"webglGetLeftBracePos\")) Module[\"webglGetLeftBracePos\"] = function() {\n abort(\"'webglGetLeftBracePos' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = function() {\n abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeGLArray\")) Module[\"writeGLArray\"] = function() {\n abort(\"'writeGLArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = function() {\n abort(\"'AL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_unicode\")) Module[\"SDL_unicode\"] = function() {\n abort(\"'SDL_unicode' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_ttfContext\")) Module[\"SDL_ttfContext\"] = function() {\n abort(\"'SDL_ttfContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_audio\")) Module[\"SDL_audio\"] = function() {\n abort(\"'SDL_audio' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = function() {\n abort(\"'SDL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = function() {\n abort(\"'SDL_gfx' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = function() {\n abort(\"'GLUT' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = function() {\n abort(\"'EGL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW_Window\")) Module[\"GLFW_Window\"] = function() {\n abort(\"'GLFW_Window' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = function() {\n abort(\"'GLFW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = function() {\n abort(\"'GLEW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = function() {\n abort(\"'IDBStore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = function() {\n abort(\"'runAndAbortIfError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function() {\n abort(\"'warnOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function() {\n abort(\"'stackSave' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function() {\n abort(\"'stackRestore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function() {\n abort(\"'stackAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function() {\n abort(\"'AsciiToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function() {\n abort(\"'stringToAscii' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function() {\n abort(\"'UTF16ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function() {\n abort(\"'stringToUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function() {\n abort(\"'lengthBytesUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function() {\n abort(\"'UTF32ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function() {\n abort(\"'stringToUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function() {\n abort(\"'lengthBytesUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function() {\n abort(\"'allocateUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = function() {\n abort(\"'allocateUTF8OnStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\n\nModule[\"writeStackCookie\"] = writeStackCookie;\n\nModule[\"checkStackCookie\"] = checkStackCookie;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n configurable: true,\n get: function() {\n  abort(\"'ALLOC_NORMAL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n }\n});\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", {\n configurable: true,\n get: function() {\n  abort(\"'ALLOC_STACK' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n }\n});\n\nvar calledRun;\n\nfunction ExitStatus(status) {\n this.name = \"ExitStatus\";\n this.message = \"Program terminated with exit(\" + status + \")\";\n this.status = status;\n}\n\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n if (!calledRun) run();\n if (!calledRun) dependenciesFulfilled = runCaller;\n};\n\nfunction stackCheckInit() {\n _emscripten_stack_init();\n writeStackCookie();\n}\n\nfunction run(args) {\n args = args || arguments_;\n if (runDependencies > 0) {\n  return;\n }\n stackCheckInit();\n preRun();\n if (runDependencies > 0) {\n  return;\n }\n function doRun() {\n  if (calledRun) return;\n  calledRun = true;\n  Module[\"calledRun\"] = true;\n  if (ABORT) return;\n  initRuntime();\n  readyPromiseResolve(Module);\n  if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n  assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n  postRun();\n }\n if (Module[\"setStatus\"]) {\n  Module[\"setStatus\"](\"Running...\");\n  setTimeout(function() {\n   setTimeout(function() {\n    Module[\"setStatus\"](\"\");\n   }, 1);\n   doRun();\n  }, 1);\n } else {\n  doRun();\n }\n checkStackCookie();\n}\n\nModule[\"run\"] = run;\n\nfunction checkUnflushedContent() {\n var oldOut = out;\n var oldErr = err;\n var has = false;\n out = err = function(x) {\n  has = true;\n };\n try {\n  var flush = Module[\"_fflush\"];\n  if (flush) flush(0);\n  [ \"stdout\", \"stderr\" ].forEach(function(name) {\n   var info = FS.analyzePath(\"/dev/\" + name);\n   if (!info) return;\n   var stream = info.object;\n   var rdev = stream.rdev;\n   var tty = TTY.ttys[rdev];\n   if (tty && tty.output && tty.output.length) {\n    has = true;\n   }\n  });\n } catch (e) {}\n out = oldOut;\n err = oldErr;\n if (has) {\n  warnOnce(\"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.\");\n }\n}\n\nfunction exit(status, implicit) {\n EXITSTATUS = status;\n checkUnflushedContent();\n if (keepRuntimeAlive()) {\n  if (!implicit) {\n   var msg = \"program exited (with status: \" + status + \"), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)\";\n   readyPromiseReject(msg);\n   err(msg);\n  }\n } else {\n  exitRuntime();\n }\n procExit(status);\n}\n\nfunction procExit(code) {\n EXITSTATUS = code;\n if (!keepRuntimeAlive()) {\n  if (Module[\"onExit\"]) Module[\"onExit\"](code);\n  ABORT = true;\n }\n quit_(code, new ExitStatus(code));\n}\n\nif (Module[\"preInit\"]) {\n if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n while (Module[\"preInit\"].length > 0) {\n  Module[\"preInit\"].pop()();\n }\n}\n\nrun();\n\n\n  return Module.ready\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);\n\n//# sourceURL=webpack://test/./node_modules/mecab-wasm/lib/libmecab.js?");

/***/ }),

/***/ "./node_modules/mecab-wasm/lib/mecab.js":
/*!**********************************************!*\
  !*** ./node_modules/mecab-wasm/lib/mecab.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _libmecab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libmecab.js */ \"./node_modules/mecab-wasm/lib/libmecab.js\");\n\n\nfunction locateFile(fn) {\n    if (fn == 'libmecab.data') {\n        return new URL(/* asset import */ __webpack_require__(/*! libmecab.data */ \"./node_modules/mecab-wasm/lib/libmecab.data\"), __webpack_require__.b).toString();\n    }\n    if (fn == 'libmecab.wasm') {\n        return new URL(/* asset import */ __webpack_require__(/*! libmecab.wasm */ \"./node_modules/mecab-wasm/lib/libmecab.wasm\"), __webpack_require__.b).toString();\n    }\n}\n\nvar lib;\nvar instance;\nconst libPromise = (0,_libmecab_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({ locateFile });\nlibPromise.then(x => { \n    lib = x;\n    instance = lib.ccall('mecab_new2', 'number', ['string'], ['']);\n});\n\nclass Mecab \n{\n    static async waitReady() {\n        await libPromise;\n    }\n\n    static query(str) {\n        if (instance == null) {\n            throw 'Mecab not ready';\n        }\n\n        let out_length = str.length * 128;\n\n        let out_arr = lib._malloc(out_length);\n        let ret = lib.ccall('mecab_sparse_tostr3', 'number', ['number', 'string', 'number', 'number', 'number'],\n                                 [instance, str, lib.lengthBytesUTF8(str)+1, out_arr, out_length]);\n        ret = lib.UTF8ToString(ret);\n        lib._free(out_arr);\n\n        if (ret.length == 0) {\n            console.log(`Mecab failed with string \"${str}\"`);\n            return [];\n        }\n\n        let result = []\n        for (let line of ret.split('\\n')) {\n            const sp = line.split('\\t');\n            if (sp.length != 2) continue;\n\n            const [ word, field_str ] = sp;\n            // , 1, 2, 3, 1, 2, , , \n            const [ pos, pos_detail1, pos_detail2, pos_detail3, conjugation1, conjugation2, dictionary_form, reading, pronunciation ] = field_str.split(',');\n            result[result.length] = { word, pos, pos_detail1, pos_detail2, pos_detail3, conjugation1, conjugation2, dictionary_form, reading, pronunciation };\n        }\n\n        return result;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Mecab);\n\n\n//# sourceURL=webpack://test/./node_modules/mecab-wasm/lib/mecab.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mecab_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mecab-wasm */ \"./node_modules/mecab-wasm/lib/mecab.js\");\n\n\nmecab_wasm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].waitReady().then(() => {\n  window.onmessage = (message) => {\n    if (typeof message !== \"string\") {\n      return;\n    }\n\n    window.postMessage(mecab_wasm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].query(message));\n  };\n});\n\n/*\nfunction init() {\n  document.getElementById(\"button\").addEventListener(\"click\", function () {\n    let text = document.getElementById(\"in\").value;\n    let result = Mecab.query(text);\n    document.getElementById(\"out\").value = JSON.stringify(result, null, 2);\n  });\n}\n\nwindow.addEventListener(\"load\", function () {\n  Mecab.waitReady().then(init);\n});*/\n\n\n//# sourceURL=webpack://test/./src/index.js?");

/***/ }),

/***/ "./node_modules/mecab-wasm/lib/libmecab.data":
/*!***************************************************!*\
  !*** ./node_modules/mecab-wasm/lib/libmecab.data ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"5e2c4a4b3a9fb4097c41.data\";\n\n//# sourceURL=webpack://test/./node_modules/mecab-wasm/lib/libmecab.data?");

/***/ }),

/***/ "./node_modules/mecab-wasm/lib/libmecab.wasm":
/*!***************************************************!*\
  !*** ./node_modules/mecab-wasm/lib/libmecab.wasm ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"02d9c0fea136bb5c0a6f.wasm\";\n\n//# sourceURL=webpack://test/./node_modules/mecab-wasm/lib/libmecab.wasm?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;